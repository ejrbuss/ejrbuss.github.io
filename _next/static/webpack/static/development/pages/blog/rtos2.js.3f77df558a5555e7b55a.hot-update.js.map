{"version":3,"file":"static/webpack/static/development/pages/blog/rtos2.js.3f77df558a5555e7b55a.hot-update.js","sources":["webpack:///./lib/Pages.js"],"sourcesContent":["\n// Generated by Page Builder\nimport Page from './Page';\nimport _    from 'lodash';\n\nexport default {\n\n    $pages() {\n        return Object.values(this).filter(page => page instanceof Page);\n    },\n\n    $blogs() {\n        return this.$pages().filter(page => page.blog).sort(Page.compareDates);\n    },\n\n    $search(searchText) {\n        const regex   = new RegExp(_.escapeRegExp(_.escape(searchText)), 'i');\n        const results = [];\n        for (const page of this.$pages()) {\n            if (page.$searchRegex(regex)) {\n                results.push(page);\n            }\n        }\n        return results;\n    },\n\n    about: new Page({\n        name: 'about',\n        content: 'I am Eric Buss. I am a developer, designer, and soon to be Software Engineer. I have a love for programming language design, functional programming, open source projects, and horror movies.\\n\\n# Skills\\nA list of the technologies I am familiar with. Related subskills are \\nlisted in \\\\[brackets\\\\].\\n\\n> JavaScript \\\\[TypeScript React CoffeeScript Express\\\\] / HTML \\\\[Jade/Pug\\\\] /\\n> CSS \\\\[Sass Less Bootstrap\\\\] / Python \\\\[Matplotlib Numpy Pandas SciPy TensorFlow\\\\] / \\n> C \\\\[C++ Objective-C iOS AVR ARM OpenGL\\\\] / Java \\\\[Clojure\\\\] / \\n> PHP \\\\[CodeIgniter\\\\] / Databases \\\\[SQL MongoDB\\\\] / R / Git / MATLAB / \\n> OS-familiarity \\\\[`icon:fab fa-windows` `icon:fab fa-apple` Ubuntu openSUSE Fedora\\\\]\\n\\nFor more information feel free to [contact me](mailto:root@ejrbuss.net) or look at my [resume](/static/rsc/resume.pdf).\\n\\n# Testimonials\\nSome nice people have had nice things to say about my work!\\n\\n> *“Thanks Eric for leading the \\\\[...\\\\] prototype. You have set a strong foundation for the coming \\\\[...\\\\] WebApp. The beauty is that, with you and John, I had no worries we would had come up with the right solution. It is also a big thank you for being that thorough on code quality which also has been a big part of \\\\[the app\\'s\\\\] success.”*\\n>\\n> **— Gino Lord (Former Supervisor)**\\n>\\n> *“Thanks for excellent work on the \\\\[App\\\\] features”*\\n>\\n> **— Aroosh Elahi (Former Supervisor)** \\n>\\n> *“Incredibly talented! Introduced style guidelines and function blocks so our app won’t be too ugly inside. Good job on your \\\\[...\\\\] prototype!\"* \\n> \\n> **— John Peng (Former Fellow Coop)**\\n>\\n> *“Unreasonably hardworking. Terribly good at what they do”*\\n> \\n> **— David Choi (Former Fellow Coop)**\\n\\n# Contact\\n\\nroot@ejrbuss.net',\n        plainTxt: 'I am Eric Buss. I am a developer, designer, and soon to be Software Engineer. I have a love for programming language design, functional programming, open source projects, and horror movies.\\nSkills\\nA list of the technologies I am familiar with. Related subskills are \\nlisted in [brackets].\\nJavaScript [TypeScript React CoffeeScript Express] / HTML [Jade/Pug] /\\nCSS [Sass Less Bootstrap] / Python [Matplotlib Numpy Pandas SciPy TensorFlow] / \\nC [C++ Objective-C iOS AVR ARM OpenGL] / Java [Clojure] / \\nPHP [CodeIgniter] / Databases [SQL MongoDB] / R / Git / MATLAB / \\nOS-familiarity [icon:fab fa-windows icon:fab fa-apple Ubuntu openSUSE Fedora]\\n\\nFor more information feel free to contact me or look at my resume.\\nTestimonials\\nSome nice people have had nice things to say about my work!\\n“Thanks Eric for leading the [...] prototype. You have set a strong foundation for the coming [...] WebApp. The beauty is that, with you and John, I had no worries we would had come up with the right solution. It is also a big thank you for being that thorough on code quality which also has been a big part of [the app&amp;#39;s] success.”\\n— Gino Lord (Former Supervisor)\\n“Thanks for excellent work on the [App] features”\\n— Aroosh Elahi (Former Supervisor) \\n“Incredibly talented! Introduced style guidelines and function blocks so our app won’t be too ugly inside. Good job on your [...] prototype!&amp;quot; \\n— John Peng (Former Fellow Coop)\\n“Unreasonably hardworking. Terribly good at what they do”\\n— David Choi (Former Fellow Coop)\\n\\nContact\\nroot@ejrbuss.net\\n',\n        route: '/about',\n        layout: '../layouts/About',\n        title: 'About',\n    }),\n    blog: new Page({\n        name: 'blog',\n        content: '',\n        plainTxt: '',\n        route: '/blog',\n        layout: '../layouts/Archive',\n        title: 'Blog Archive',\n    }),\n    github: new Page({\n        name: 'github',\n        content: '',\n        plainTxt: '',\n        route: '/blog/github',\n        layout: '../../layouts/Blog',\n        title: 'GitHub Catalog',\n        subtitle: 'A trip down memory lane. I catalog all of my GitHub repositories, both finished projects, and those that never got off the ground.',\n        blog: true,\n        date: '05-15-2019',\n    }),\n    rtos1: new Page({\n        name: 'rtos1',\n        content: '> # Author\\'s Note\\n>\\n> *This blog post is part one in a series originally put together for the University of Victoria\\'s CSC 460 course. The original content was publishd February 6 2019 by [Torrey Randolph](https://github.com/torreyr) and myself. As that webpage no longer exists I am now hosting the content here.*\\n\\n# Introduction\\n\\nThe goal of project 1 was to familiarize ourselves with the hardware and software interfaces we would be using throughout the semester. This project was broken in to two phases, details of which are provided below. This introductory section breaks down the software, hardware, and shared design decisions that were used to complete project 1.\\n\\nIn phase 1 we integrate these elements into a working solution. We control and aim a laser using an analog stick and detect the laser using a photocell. In phase 2 we create a similar solution, only this time we split the components across two boards and connect them together over Bluetooth.\\n\\n## Software Dependencies\\n\\nWe took advantage of the software ecosystem provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\\n\\n - [VS Code](https://code.visualstudio.com/): We opted to move away from Arduino IDE to a more developed code editor after completing exercises 1 through 5. Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\\n - [AVR Toolchain](https://www.nongnu.org/avr-libc/): In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR micro-controllers. AVR Libc is the backbone of the Arduino libraries. We included the source code of relevant Arduino libraries with our projects for ease of integration with hardware. These libraries include [ArduinoCore-avr](https://github.com/arduino/ArduinoCore-avr), [Servo](https://github.com/arduino-libraries/Servo), and [LiquidCrystal](https://github.com/arduino-libraries/LiquidCrystal). The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\\n - [Mekpie](https://ejrbuss.net/mekpie/): Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \\n - [Saleae Logic](https://www.saleae.com/): This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\\n\\n## Hardware\\n\\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\\n - [2x Arduino Mega 2560 boards](https://store.arduino.cc/usa/arduino-mega-2560-rev3): Only one of these was needed in phase 1, but phase 2 required the creation of a base and remote station.\\n - [2x SG-90 Micro Servos](http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf) in a pan and tilt module: These two servos are used to aim a mounted KY-008 Laser.\\n - [2x HC-06 Bluetooth modules](http://wiki.sunfounder.cc/index.php?title=Bluetooth_Transceiver_Module_HC-06): These two Bluetooth modules are used to communicate between the base and remote stations in phase 2.\\n - [Arduino LCD KeyPad Shield](https://www.dfrobot.com/wiki/index.php/Arduino_LCD_KeyPad_Shield_(SKU:_DFR0009)): The Liquid Crystal Display is used to display relevant information, such as the current X and Y values of the analog stick.\\n - [Arduino KY-023 Joystick](https://tkkrlab.nl/wiki/Arduino_KY-023_XY-axis_joystick_module): An analog joystick used to control the motion of the pan and tilt module.\\n - [KY-008 Laser](http://henrysbench.capnfatz.com/henrys-bench/arduino-output-devices/ky-008-arduino-laser-module-guide-and-tutorial/): This laser is used to shoot at our photocell. \\n - [photocell](https://learn.adafruit.com/photocells): Used to detect the laser.\\n\\n## Fixed Point Operations\\n\\nThe AVR processor does not have built in support for floating point types. As a consequence, floating point operations are achieved using software. This has the drawback that performing floating point arithmetic is significantly slower than integer arithmetic, transforming 1-cycle instructions into 200 plus cycle instructions. This had a noticeable performance impact during exercise 4 when contrasting floating point analysis of an analog signal to integer analysis. When considering performance and our overarching goal of achieving low power consumption, it is in our interest to have as few floating point operations in our solution as possible.\\n\\nWhen considering how to approach calculations typically done with floating point types, such as a low pass filter, we decided that fixed point operation may fit our needs.\\n\\nFixed point types can be considered integer values that are scaled up and down to represent smaller values. For instance, a fixed point scale of 10 would mean that 15 represents 1.5, and 57 represents 5.7. For efficient transformation to and from a fixed point format embedded programmers typically use a scale that is a power of 2. This allows scaling to be done by bit shifting. Fixed point numbers used in this way are typically expressed in the form QI.F where Q is the \"sign\" bit (in the 2\\'s complement sense), I is the integer bits, and F is the fractional bits. So our chosen fixed point format of Q7.8 translates to a 16-bit value of the form:\\n\\n```math\\nSign bit → 0 Integer bits → 0000000 Fractional bits → 00000000\\n```\\n\\nThe implementation of the data type is quite straightforward. Q7.8 corresponds to a scale of 0x0100.\\n\\n```lang:c-readonly\\n// [-128.996, 127.996]\\n#define Q78_SCALE_FACTOR 0x0100\\n\\n// Q7.8\\ntypedef s16 Q78_t;\\n\\n#define Q78(n) ((Q78_t) ((n) * Q78_SCALE_FACTOR))\\n```\\n\\nWe provide a type definition and a conversion macro for convenience.  A macro is used rather than a function to allow for optimization of numeric constants. If a fixed point number is immediately added to or subtracted from a numeric constant and it is initialized using a macro, the numeric constants can be pre-applied by the compiler.\\n\\nFixed point numbers have several advantages, the first being that addition and subtraction are trivial. Integer addition and subtraction of fixed point values sharing the same scale work without additional effort. Multiplication and division requires a little more work, but not much. \\n\\n```lang:c-readonly\\nQ78_t Q78_mul(Q78_t a, Q78_t b) {\\n    s32 tmp_a = a;\\n    s32 tmp_b = b;\\n    s32 tmp_c = (tmp_a * tmp_b) / Q78_SCALE_FACTOR;\\n    return (Q78_t) tmp_c;\\n}\\n\\nQ78_t Q78_div(Q78_t a, Q78_t b) {\\n    s32 tmp_a = a;\\n    s32 tmp_b = b;\\n    s32 tmp_c = (tmp_a * Q78_SCALE_FACTOR) / tmp_b;\\n    return (Q78_t) tmp_c;\\n}\\n\\nQ78_t Q78_lpf(Q78_t sample, Q78_t average, Q78_t factor) {\\n    static Q78_t one = Q78(1);\\n    return Q78_mul(sample, factor) + Q78_mul(average, (one - factor));\\n}\\n```\\n\\nThe key to these operations is ensuring that you do not overflow your intermediate values, hence both multiplication and division use 32-bit integers for intermediate values. In addition to multiplication and division operations, we also implement a simple low pass filter using fixed point values.\\n\\nThe core drawback of fixed point numbers is their limited range. For Q7.8 we can represent values between -128.996 and 127.996. This means that wherever we take advantage of fixed point numbers in our project we must ensure that our operands and results fit within that range.\\n\\nThe implementation of fixed point discussed here is based off a series of [online lectures on the topic by Eli Hughes](https://www.youtube.com/watch?v=bbFBgXndmP0). Fixed point numbers are just one solution in a sea of possible ways of representing and computing the results of fractional arithmetic. We also looked into rational number formats, but ultimately preferred fixed point representations because of their simplicity.\\n\\n# Phase 1\\n\\n## Overview\\n\\nThe goal of phase 1 was to use an analog stick to control and aim a laser to shoot a photocell that could subsequently detect the shot. All of these components were integrated using a single Arduino board. Thanks to the five exercises completed prior to phase 1. producing our solution was a smooth process. The block diagram below shows the general setup of our system.\\n\\n![phase 1 block diagram](/static/blog/rtos1/phase-1-block.jpg)\\n\\nA 10kΩ resistor was used to create a voltage divider for our photocell. As the resistance of the photocell changes when light is shone on it, the voltage across the 10kΩ resistor changes. That voltage is reported by the Mega 2560, mapped to the range (0, 1023). When the photocell is hit by the laser, the voltage reported increases to above a certain threshold, which was determined by trial and error.\\n\\n![phase 1 voltage divider](/static/blog/rtos1/voltage-divider.jpg)\\n\\nPhase 1 featured a simple main loop where we sample the analog stick, adjust the servos, toggle the laser, and then check if our photocell has been hit. There are no delays in this process so we simply try to go through these steps as quickly as possible, and then repeat. This is a poor solution when considering power consumption, as the CPU is never idle. It is important that the LCD is only updated when the photocell actually changes state. We discovered this in an earlier implementation where updating the LCD on every iteration of our main loop resulted in an unintelligible output from the LCD.\\n\\n```lang:c-readonly\\nfor (;;) {\\n    map_servo_pan(sample_stick_u_x(), 0, STICK_U_OFFSET_X);\\n    map_servo_tilt(-sample_stick_u_y(), 0, STICK_U_OFFSET_Y);\\n    if (stick_u_down()) {\\n        set_laser(ON);\\n    } else {\\n        set_laser(OFF);\\n    }\\n    if (photocell_hit()) {\\n        lcd.clear();\\n        lcd.print(\"Hit :O\");\\n        set_laser(OFF);\\n        break;\\n    }\\n}\\n```\\n\\nOur sampling method for the analog sticks was established during exercise 4. We use a combination of a low pass filter and a clamp. For efficient computing, these computations are performed using fixed point values. After reading the raw analog value, we scale it down so that it will fit within the fixed point range, and then offset it so that the values are centred at 0. This makes more efficient use of the signed fixed point range.\\n\\nAfter reading, scaling, and offsetting our value we pass it through a simple low pass filter. The low pass filter is implemented as a simple rolling average function. Passing the value through the low pass filter reduces noise and gets us smoother feeling control with the stick. We pass all values into the low pass filter, including those that fall into the dead zone. This increases the accuracy of our rolling average.\\n\\nThe previously mentioned dead zone is a small region around the zero signal of the stick, that is clamped down to 0. This clamping combats two issues with analog inputs. The first is that the sticks have some noise in their input signal, even when at rest. This means that the measured value can be greater or less than 0 even if no one is touching the stick. Additionally, the sticks do not always come to rest at the exact same position due to friction, wear, and manufacturing imperfections. A dead zone mitigates these issues.\\n\\nOur dead zone is implemented using a clamp. We similarly clamp the maximum value slightly below the theoretical maximum. This ensures that when you push the stick to the furthest edge in any direction we return the same maximum value.\\n\\nPutting all of these decisions together we end up with the following implementation.\\n\\n```lang:c-readonly\\n\\nint sample_stick_u_x() {\\n    static Q78_t rolling_x = Q78(0);\\n    static Q78_t sample_x  = Q78(0);\\n    sample_x  = Q78((analogRead(STICK_U_PIN_X) - STICK_U_OFFSET_X) / STICK_SCALE);\\n    rolling_x = Q78_lpf(sample_x, rolling_x, STICK_LFP_FACTOR);\\n    int x     = Q78_to_int(rolling_x);\\n    if (x < 0) {\\n        x = clamp(x + STICK_U_DEADZONE, STICK_U_MIN_X, 0);\\n    } else if (x > 0) {\\n        x = clamp(x - STICK_U_DEADZONE, 0, STICK_U_MAX_X);\\n    }\\n    return x;\\n}\\n```\\n\\nCorrectly performing these operations requires we measure out constants for each analog stick. Namely their minimum, maximum, and resting values. We determined these values using a separate program, and recorded the constants for each of our two sticks. This ensures we are obtaining the highest quality samples possible.\\n\\nWe map the stick values to the servo positions in an intelligent manner. The servo is moved in discrete steps. These steps enforce a maximum delta in position and a minimum delay between changes. This protects the servo from having its position changed too rapidly, which could damage it.\\n\\nThe implementation first checks to see if the servos are ready to have their positions changed again; this is done by keeping track of the last time they were called using Arduino\\'s millis function. If sufficient time has passed we change the input into a fractional value between 0 and 1 and multiply this by our maximum delta. This means that small changes will map to slow rotation of the servo and large changes will map to fast rotation of the servo. We also clamp the delta again to ensure that we do not exceed our maximum delta due to incorrect arguments. Finally, we clamp the position before writing it to ensure we do not move the servo past its maximum range. Most of these operations are performed with fixed point values for efficiency.\\n\\n```lang:c-readonly\\nvoid map_servo_pan(int value, int min_value, int max_value) {\\n    static int servo_pan_position = SERVO_PAN_CENTER;\\n    static int last_call = 0;\\n    int this_call = millis();\\n    if (this_call - last_call < SERVO_PAN_DELAY) {\\n        return;\\n    }\\n    last_call = this_call;\\n    Q78_t range = Q78(SERVO_PAN_MAX_SPEED);\\n    Q78_t ratio = Q78_div(Q78(value - min_value), Q78(max_value));\\n    Q78_t delta = Q78_mul(range, ratio);\\n    servo_pan_position += clamp(Q78_to_int(delta), -SERVO_PAN_MAX_SPEED, SERVO_PAN_MAX_SPEED);\\n    servo_pan_position =  clamp(servo_pan_position, SERVO_PAN_BOTTOM, SERVO_PAN_TOP);\\n    servo_pan.writeMicroseconds(servo_pan_position);\\n}\\n```\\n\\n# Phase 2\\n\\n## Overview\\n\\nThe goal of phase 2 was to separate the components into two stations, each with a Mega 2560 board and have them communicate over Bluetooth. Below are block diagrams of the two stations.\\n\\n![phase 2 block diagram 1](/static/blog/rtos1/phase-2-block-1.jpg)\\n\\n![phase 2 block diagram 2](/static/blog/rtos1/phase-2-block-2.jpg)\\n\\nThe base station includes the LCD, the joystick, the photocell, and one of the Bluetooth modules connected to a Mega 2560. The remote station consists of the pan and tilt servo motors, the laser, and the other Bluetooth module connected to another Mega 2560. The base station sends the joystick position to the remote station, which updates the servo motors and the laser positions correspondingly. In our implementation, the base station also sends a done flag when the photocell is hit by the laser to indicate that the program should gracefully shut down.\\n\\n##  Polling and TTA\\n\\nPhase 2 is to be implemented using a time triggered architecture (TTA). We make use of a [scheduler developed by Neil MacMillan](https://nrqm.ca/mechatronics-lab-guide/lab-guide-time-triggered-scheduling/), a former TA of this course. In a TTA, tasks, implemented here as C functions, are run on a set period. In between these tasks the CPU is simply left to idle. A TTA has a number of benefits to real-time systems.\\n\\n - They are deterministic; a correct schedule will remain correct ad infinitum.\\n - They are simple, especially compared to preemptive schedulers.\\n - They are lightweight, as the scheduler itself has very little bookkeeping to accomplish.\\n\\nThe choice of a TTA led us to the decision of avoiding interrupts in both phase 1 and 2. TTA nicely integrates with polling-based algorithms, so for all our inputs and communication we use polling rather than interrupts to keep up with IO.\\n\\nIn our implementation the base station and remote station both alternated between two tasks. The base station had the task sample for collecting input from the analog stick and photocell, and send for packaging that information together and sending it over Bluetooth. The remote station had the task receive for collecting the information sent from the base station and control for using that information in the activation of the laser and servo motors. The actual implementation of these tasks rely on the same code presented in phase 1.\\n\\nWe elected to sample our analog stick at approximately 60Hz. This was done based off the knowledge that responsive video games typically target 60 frames per second. We then match this rate in sending out the input information to the remote station. In retrospect, it would be worth investigating sampling at an even higher rate, and sending at the same or slightly slower rate. The logic being that the low pass filter we apply to our analog stick input would be most effective on an over sampled input.\\n\\nOn the remote station we faced a number of issues actually receiving a message. We hypothesized that this was due to two core problems:\\n\\n1. The Bluetooth and/or UART pin on the board had a limited buffer which could overflow and produce unexpected results.\\n2. The first byte sent by our base station did not always correspond to the first byte read by our remote station.\\n\\nPart of the reason these two problems caused us so much pain was that we had elected to communicate by sending a struct over Bluetooth. This meant that getting the correct values depended completely on byte order, unlike in something like a JSON encoding, where the relative position of data could be preserved.\\n\\nWhen developing our solution, the first of these problems caused a number of strange behaviours, such as a massive delay between the initial push of the analog joystick and the servo activating, as well as the remote station randomly indicating it had been sent the done signal. These issues went away once we over sampled our Bluetooth signal (we landed at a rate of about 100Hz). This prevented the Bluetooth buffer from growing too large which caused delay, and upon overflow, incorrect values. Because we prevent our receive task from reading the next message until the servos have been given new values, we also had to have our control task update at a similarly high rate. In the future it may be worth exploring a slower control rate combined with aggregating received messages.\\n\\nThe second issue of byte alignment we solved by developing a simple communication protocol.\\n\\n## Communication Protocol\\n\\nA struct was used to communicate our data over Bluetooth. We used a four byte header for alignment. Shown below are the definitions of the struct and relevant constants.\\n\\n```lang:c-readonly\\n#define MESSAGE_HEADER ((u32) 0x04030201)\\n#define MESSAGE_DONE   0b00000001\\n#define MESSAGE_LASER  0b00000010\\n\\ntypedef struct Message Message;\\nstruct Message {\\n#ifdef MESSAGE_SENDER\\n    u32 header;\\n#endif\\n    s8 u_x;\\n    s8 u_y;\\n    s8 m_x;\\n    s8 m_y;\\n    u8 flags;\\n};\\n```\\n\\nFor our data values we selected as efficient of integer types as reasonably possible. Our analog stick values come from fixed point calculations, meaning they are guaranteed to be between -128 and 127, which means a single signed byte is all that is needed to communicate each stick position. We send the done flag and laser state in a single shared byte, as this is the smallest reasonable encoding for that binary data.\\n\\nThe 4-byte header provides a means of synchronizing the remote and base stations. Having the remote station wait until it has correctly read the header will help guarantee data correctness. We started with an 8-byte header that simply counted from 1 to 8. Immediately we ran into an issue of endianness, as a u64 of 0x0102030405060708 is actually encoded low byte first in memory on our boards. Since we were reading these bytes one at a time at the remote station we had to reverse the order of our header value. Once we had a working system we lowered the header down to 4 bytes and found there was no loss in correctness. More clever schemes for alignment could be devised. Two that we considered are as follows:\\n\\n - The Bluetooth modules seems to provide a reliable connection, meaning we could attempt to synchronize only once at startup and then trust that we will receive every byte in alignment.\\n - We could use a single byte for alignment, such as 0xFF, and to ensure correctness enforce the policy that all fields of our message struct are never allowed to encode this value.\\n\\nUltimately,  we preferred our solution for its simplicity and reliability. In terms of implementing this protocol, the main work rested on the remote station. Its process of receiving bytes can be modeled using a simple state machine, shown below.\\n\\n![State Machine](/static/blog/rtos1/state-diagram.jpg)\\n\\nThe four-byte header precedes each message. One drawback to this design is that if the remote station misses the header for any reason, that message will be skipped and the information will be lost. If the remote station successfully sees the header, the next five bytes it reads will be the message data, which it will subsequently map to servo positions and the laser state.\\n\\nThe implementation of send for this protocol is provided below. We send the struct byte by byte over Bluetooth. If we assume our receiver will similarly copy our bytes into a buffer of the same type, this has the nice feature of not caring about endianness, so long as the client and host agree. \\n\\n```lang:c-readonly\\nvoid send() {\\n    digitalWrite(LOGIC_SEND, HIGH);\\n    // Write each byte of current message onse at a time\\n    u8 * buffer = (u8 *) &current_message;\\n    u16 i;\\n    for (i = 0; i < sizeof(Message); i++) {\\n        Serial1.write(buffer[i]);\\n    }\\n    digitalWrite(LOGIC_SEND, LOW);\\n}\\n```\\n\\nThe receive function is slightly more complex. First it must correctly implement the aforementioned state machine, as well as the function should not block if serial input from the Bluetooth is not available. The later issue is nicely resolved using static variables. For ease of implementation we generalize the first four states into a single handler.\\n\\n```lang:c-readonly\\nvoid receive() {\\n\\n    static int i = 0;\\n    static int state = header1;\\n\\n    digitalWrite(LOGIC_RECEIVE, HIGH);\\n    if (current_message == NULL) {\\n        u8 * buffer = (u8 *) &buffer_message;\\n        while (Serial1.available()) {\\n            switch(state) {\\n                case header1:\\n                case header2:\\n                case header3:\\n                case header4:\\n                    if (Serial1.read() == state) {\\n                        state++;\\n                    } else {\\n                        state = header1;\\n                    }\\n                    break;\\n                case data:\\n                    // Read as much as is available\\n                    while (Serial1.available()) {\\n                        buffer[i++] = Serial1.read();\\n                        if (i == sizeof(Message)) {\\n                            current_message = &buffer_message;\\n                            state = header1;\\n                            i = 0;\\n                            digitalWrite(LOGIC_RECEIVE, LOW);\\n                            return;\\n                        }\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n    }\\n    digitalWrite(LOGIC_RECEIVE, LOW);\\n}\\n```\\n\\nIt is worth noting that both functions above provide code for setting a pin high when the function is entered, and low when the function returns. This is used for observations using the logic analyzer in the following section.\\n\\n## CPU Utilization\\n\\nTiming measurements were taken using both internal software and an external logic analyzer. Low CPU utilization is preferred in order to save power. In real world real-time systems, power consumption translates directly to cost. Additionally, low CPU utilization will allow for additional tasks in the project.\\n\\n### Base Station\\n\\nThe base station\\'s two tasks, sample and send, were both set to run periodically every 16 milliseconds (approximately 60Hz). As previously mentioned, at the beginning of each task, a digital output pin was set to high, and at the end of each task that same pin was set to low. A Saleae logic analyzer was used to record these pin level changes and measure the durations of the two tasks. From the screenshot below, it can be seen that the time triggered scheduler does not guarantee precise periods. In this instance, the experimental periods of sample and send were 17.11ms and 16.08ms, respectively. \\n\\n![Logic 1](/static/blog/rtos1/logic-1.png)\\n\\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the sample task took 907 μs and the execution of the send task took 57.5 μs. It makes sense that sample takes longer because it has to obtain the state of multiple IO devices, as well as apply four low pass filters. In contrast, send simply has to send 9 bytes of data to the built-in UART.\\n\\nFrom these measurements, the CPU utilization can be calculated as\\n\\n```math\\npercent used = ((Sample_duration / Sample_period) + (Send_duration / Send_period)) × 100%\\n```\\n\\nUsing the measurements below, the CPU is in use 5.66% of the time. That translates to 94% idle time. Note that this is a rough value because of the inconsistency in the scheduler. A more accurate value could be estimated by averaging more samples from the logic analyzer.\\n\\n![Logic 2](/static/blog/rtos1/logic-2.png)\\n\\n### Remote Station\\n\\nThe remote station\\'s two tasks, control and receive, were both set to run periodically every 10 milliseconds (approximately 100Hz).  As explained above, the higher frequency of the remote station tasks versus the base station tasks ensured an acceptable level of responsiveness in the IO devices and prevented the Bluetooth buffer from filling up.\\n\\nDepicted below, the experimental periods of control and receive were 9.343ms and 10.16ms, respectively. \\n\\n![Logic 3](/static/blog/rtos1/logic-3.png)\\n\\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the control task took 193 μs and the execution of the receive task took 55 μs. It makes sense that control takes longer because it has to adjust the state of multiple IO devices, whereas receive simply has to read from the UART. It is also worth noting that the computation time of control varies significantly. This is because on some calls the servo is not ready to receive a new position, which decreases the computation cost significantly. \\n\\nUsing the same equation as above, and the measurements listed below, CPU utilization was found to be 2.61%, which translates to roughly 97% idle time. \\n\\n![Logic 4](/static/blog/rtos1/logic-4.png)\\n\\nWe also measured our percentage of idle time in software. We used a simple process to determine this.\\n\\n1. We recorded the time in milliseconds prior to entering the main loop.\\n2. Each time the time triggered scheduler returns with an idle time duration we add it to an ongoing sum.\\n3. When we exit the main loop we record the end time in milliseconds.\\n4. We calculated idle percentage as:\\n\\n```math\\npercent idle = idle time / (start time - end time) × 100%\\n```\\n\\nUsing this measurement method, we found that on average our base station was idle 93% of the time and our remote station was idle 98% of the time. These correlate closely with the results obtained from the logic analyzer (94% and 97%). Looking at our logical analyzer results it is clear that sampling inputs and controlling the servos is taking up the large majority of the processing time. If we wanted to improve our CPU utilization, this would be our starting point.\\n\\n# Conclusion\\n\\nNow that we have completed project 1 we are preparing and planning for project 2 where we will expand upon our current TTA, developing it into our own simple real-time operating system.\\n\\n# References\\n\\n\\\\[1\\\\] M. Cheng, \"Project 3\", *Webhome.csc.uvic.ca*, 2019. \\\\[Online\\\\]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. \\\\[Accessed: Apr-2019\\\\].\\n\\n\\\\[2\\\\] E. Hughes, \"Introduction to Fixed Point Math\", 2014. \\\\[Online\\\\]. Available: https://www.youtube.com/watch?v=bbFBgXndmP0. \\\\[Accessed: Apr-2019\\\\].',\n        plainTxt: 'Author&amp;#39;s Note\\nThis blog post is part one in a series originally put together for the University of Victoria&amp;#39;s CSC 460 course. The original content was publishd February 6 2019 by Torrey Randolph and myself. As that webpage no longer exists I am now hosting the content here.\\n\\nIntroduction\\nThe goal of project 1 was to familiarize ourselves with the hardware and software interfaces we would be using throughout the semester. This project was broken in to two phases, details of which are provided below. This introductory section breaks down the software, hardware, and shared design decisions that were used to complete project 1.\\nIn phase 1 we integrate these elements into a working solution. We control and aim a laser using an analog stick and detect the laser using a photocell. In phase 2 we create a similar solution, only this time we split the components across two boards and connect them together over Bluetooth.\\nSoftware Dependencies\\nWe took advantage of the software ecosystem provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\\nVS Code: We opted to move away from Arduino IDE to a more developed code editor after completing exercises 1 through 5. Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\\nAVR Toolchain: In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR micro-controllers. AVR Libc is the backbone of the Arduino libraries. We included the source code of relevant Arduino libraries with our projects for ease of integration with hardware. These libraries include ArduinoCore-avr, Servo, and LiquidCrystal. The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\\nMekpie: Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \\nSaleae Logic: This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\\n\\nHardware\\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\\n2x Arduino Mega 2560 boards: Only one of these was needed in phase 1, but phase 2 required the creation of a base and remote station.\\n2x SG-90 Micro Servos in a pan and tilt module: These two servos are used to aim a mounted KY-008 Laser.\\n2x HC-06 Bluetooth modules: These two Bluetooth modules are used to communicate between the base and remote stations in phase 2.\\nArduino LCD KeyPad Shield: The Liquid Crystal Display is used to display relevant information, such as the current X and Y values of the analog stick.\\nArduino KY-023 Joystick: An analog joystick used to control the motion of the pan and tilt module.\\nKY-008 Laser: This laser is used to shoot at our photocell. \\nphotocell: Used to detect the laser.\\n\\nFixed Point Operations\\nThe AVR processor does not have built in support for floating point types. As a consequence, floating point operations are achieved using software. This has the drawback that performing floating point arithmetic is significantly slower than integer arithmetic, transforming 1-cycle instructions into 200 plus cycle instructions. This had a noticeable performance impact during exercise 4 when contrasting floating point analysis of an analog signal to integer analysis. When considering performance and our overarching goal of achieving low power consumption, it is in our interest to have as few floating point operations in our solution as possible.\\nWhen considering how to approach calculations typically done with floating point types, such as a low pass filter, we decided that fixed point operation may fit our needs.\\nFixed point types can be considered integer values that are scaled up and down to represent smaller values. For instance, a fixed point scale of 10 would mean that 15 represents 1.5, and 57 represents 5.7. For efficient transformation to and from a fixed point format embedded programmers typically use a scale that is a power of 2. This allows scaling to be done by bit shifting. Fixed point numbers used in this way are typically expressed in the form QI.F where Q is the &amp;quot;sign&amp;quot; bit (in the 2&amp;#39;s complement sense), I is the integer bits, and F is the fractional bits. So our chosen fixed point format of Q7.8 translates to a 16-bit value of the form:\\nSign bit → 0 Integer bits → 0000000 Fractional bits → 00000000\\nThe implementation of the data type is quite straightforward. Q7.8 corresponds to a scale of 0x0100.\\n// [-128.996, 127.996]\\n#define Q78_SCALE_FACTOR 0x0100\\n\\n// Q7.8\\ntypedef s16 Q78_t;\\n\\n#define Q78(n) ((Q78_t) ((n) * Q78_SCALE_FACTOR))\\nWe provide a type definition and a conversion macro for convenience.  A macro is used rather than a function to allow for optimization of numeric constants. If a fixed point number is immediately added to or subtracted from a numeric constant and it is initialized using a macro, the numeric constants can be pre-applied by the compiler.\\nFixed point numbers have several advantages, the first being that addition and subtraction are trivial. Integer addition and subtraction of fixed point values sharing the same scale work without additional effort. Multiplication and division requires a little more work, but not much. \\nQ78_t Q78_mul(Q78_t a, Q78_t b) {\\n    s32 tmp_a = a;\\n    s32 tmp_b = b;\\n    s32 tmp_c = (tmp_a * tmp_b) / Q78_SCALE_FACTOR;\\n    return (Q78_t) tmp_c;\\n}\\n\\nQ78_t Q78_div(Q78_t a, Q78_t b) {\\n    s32 tmp_a = a;\\n    s32 tmp_b = b;\\n    s32 tmp_c = (tmp_a * Q78_SCALE_FACTOR) / tmp_b;\\n    return (Q78_t) tmp_c;\\n}\\n\\nQ78_t Q78_lpf(Q78_t sample, Q78_t average, Q78_t factor) {\\n    static Q78_t one = Q78(1);\\n    return Q78_mul(sample, factor) + Q78_mul(average, (one - factor));\\n}\\nThe key to these operations is ensuring that you do not overflow your intermediate values, hence both multiplication and division use 32-bit integers for intermediate values. In addition to multiplication and division operations, we also implement a simple low pass filter using fixed point values.\\nThe core drawback of fixed point numbers is their limited range. For Q7.8 we can represent values between -128.996 and 127.996. This means that wherever we take advantage of fixed point numbers in our project we must ensure that our operands and results fit within that range.\\nThe implementation of fixed point discussed here is based off a series of online lectures on the topic by Eli Hughes. Fixed point numbers are just one solution in a sea of possible ways of representing and computing the results of fractional arithmetic. We also looked into rational number formats, but ultimately preferred fixed point representations because of their simplicity.\\nPhase 1\\nOverview\\nThe goal of phase 1 was to use an analog stick to control and aim a laser to shoot a photocell that could subsequently detect the shot. All of these components were integrated using a single Arduino board. Thanks to the five exercises completed prior to phase 1. producing our solution was a smooth process. The block diagram below shows the general setup of our system.\\nphase 1 block diagram\\nA 10kΩ resistor was used to create a voltage divider for our photocell. As the resistance of the photocell changes when light is shone on it, the voltage across the 10kΩ resistor changes. That voltage is reported by the Mega 2560, mapped to the range (0, 1023). When the photocell is hit by the laser, the voltage reported increases to above a certain threshold, which was determined by trial and error.\\nphase 1 voltage divider\\nPhase 1 featured a simple main loop where we sample the analog stick, adjust the servos, toggle the laser, and then check if our photocell has been hit. There are no delays in this process so we simply try to go through these steps as quickly as possible, and then repeat. This is a poor solution when considering power consumption, as the CPU is never idle. It is important that the LCD is only updated when the photocell actually changes state. We discovered this in an earlier implementation where updating the LCD on every iteration of our main loop resulted in an unintelligible output from the LCD.\\nfor (;;) {\\n    map_servo_pan(sample_stick_u_x(), 0, STICK_U_OFFSET_X);\\n    map_servo_tilt(-sample_stick_u_y(), 0, STICK_U_OFFSET_Y);\\n    if (stick_u_down()) {\\n        set_laser(ON);\\n    } else {\\n        set_laser(OFF);\\n    }\\n    if (photocell_hit()) {\\n        lcd.clear();\\n        lcd.print(&quot;Hit :O&quot;);\\n        set_laser(OFF);\\n        break;\\n    }\\n}\\nOur sampling method for the analog sticks was established during exercise 4. We use a combination of a low pass filter and a clamp. For efficient computing, these computations are performed using fixed point values. After reading the raw analog value, we scale it down so that it will fit within the fixed point range, and then offset it so that the values are centred at 0. This makes more efficient use of the signed fixed point range.\\nAfter reading, scaling, and offsetting our value we pass it through a simple low pass filter. The low pass filter is implemented as a simple rolling average function. Passing the value through the low pass filter reduces noise and gets us smoother feeling control with the stick. We pass all values into the low pass filter, including those that fall into the dead zone. This increases the accuracy of our rolling average.\\nThe previously mentioned dead zone is a small region around the zero signal of the stick, that is clamped down to 0. This clamping combats two issues with analog inputs. The first is that the sticks have some noise in their input signal, even when at rest. This means that the measured value can be greater or less than 0 even if no one is touching the stick. Additionally, the sticks do not always come to rest at the exact same position due to friction, wear, and manufacturing imperfections. A dead zone mitigates these issues.\\nOur dead zone is implemented using a clamp. We similarly clamp the maximum value slightly below the theoretical maximum. This ensures that when you push the stick to the furthest edge in any direction we return the same maximum value.\\nPutting all of these decisions together we end up with the following implementation.\\n\\nint sample_stick_u_x() {\\n    static Q78_t rolling_x = Q78(0);\\n    static Q78_t sample_x  = Q78(0);\\n    sample_x  = Q78((analogRead(STICK_U_PIN_X) - STICK_U_OFFSET_X) / STICK_SCALE);\\n    rolling_x = Q78_lpf(sample_x, rolling_x, STICK_LFP_FACTOR);\\n    int x     = Q78_to_int(rolling_x);\\n    if (x &lt; 0) {\\n        x = clamp(x + STICK_U_DEADZONE, STICK_U_MIN_X, 0);\\n    } else if (x &gt; 0) {\\n        x = clamp(x - STICK_U_DEADZONE, 0, STICK_U_MAX_X);\\n    }\\n    return x;\\n}\\nCorrectly performing these operations requires we measure out constants for each analog stick. Namely their minimum, maximum, and resting values. We determined these values using a separate program, and recorded the constants for each of our two sticks. This ensures we are obtaining the highest quality samples possible.\\nWe map the stick values to the servo positions in an intelligent manner. The servo is moved in discrete steps. These steps enforce a maximum delta in position and a minimum delay between changes. This protects the servo from having its position changed too rapidly, which could damage it.\\nThe implementation first checks to see if the servos are ready to have their positions changed again; this is done by keeping track of the last time they were called using Arduino&amp;#39;s millis function. If sufficient time has passed we change the input into a fractional value between 0 and 1 and multiply this by our maximum delta. This means that small changes will map to slow rotation of the servo and large changes will map to fast rotation of the servo. We also clamp the delta again to ensure that we do not exceed our maximum delta due to incorrect arguments. Finally, we clamp the position before writing it to ensure we do not move the servo past its maximum range. Most of these operations are performed with fixed point values for efficiency.\\nvoid map_servo_pan(int value, int min_value, int max_value) {\\n    static int servo_pan_position = SERVO_PAN_CENTER;\\n    static int last_call = 0;\\n    int this_call = millis();\\n    if (this_call - last_call &lt; SERVO_PAN_DELAY) {\\n        return;\\n    }\\n    last_call = this_call;\\n    Q78_t range = Q78(SERVO_PAN_MAX_SPEED);\\n    Q78_t ratio = Q78_div(Q78(value - min_value), Q78(max_value));\\n    Q78_t delta = Q78_mul(range, ratio);\\n    servo_pan_position += clamp(Q78_to_int(delta), -SERVO_PAN_MAX_SPEED, SERVO_PAN_MAX_SPEED);\\n    servo_pan_position =  clamp(servo_pan_position, SERVO_PAN_BOTTOM, SERVO_PAN_TOP);\\n    servo_pan.writeMicroseconds(servo_pan_position);\\n}\\nPhase 2\\nOverview\\nThe goal of phase 2 was to separate the components into two stations, each with a Mega 2560 board and have them communicate over Bluetooth. Below are block diagrams of the two stations.\\nphase 2 block diagram 1\\nphase 2 block diagram 2\\nThe base station includes the LCD, the joystick, the photocell, and one of the Bluetooth modules connected to a Mega 2560. The remote station consists of the pan and tilt servo motors, the laser, and the other Bluetooth module connected to another Mega 2560. The base station sends the joystick position to the remote station, which updates the servo motors and the laser positions correspondingly. In our implementation, the base station also sends a done flag when the photocell is hit by the laser to indicate that the program should gracefully shut down.\\nPolling and TTA\\nPhase 2 is to be implemented using a time triggered architecture (TTA). We make use of a scheduler developed by Neil MacMillan, a former TA of this course. In a TTA, tasks, implemented here as C functions, are run on a set period. In between these tasks the CPU is simply left to idle. A TTA has a number of benefits to real-time systems.\\nThey are deterministic; a correct schedule will remain correct ad infinitum.\\nThey are simple, especially compared to preemptive schedulers.\\nThey are lightweight, as the scheduler itself has very little bookkeeping to accomplish.\\n\\nThe choice of a TTA led us to the decision of avoiding interrupts in both phase 1 and 2. TTA nicely integrates with polling-based algorithms, so for all our inputs and communication we use polling rather than interrupts to keep up with IO.\\nIn our implementation the base station and remote station both alternated between two tasks. The base station had the task sample for collecting input from the analog stick and photocell, and send for packaging that information together and sending it over Bluetooth. The remote station had the task receive for collecting the information sent from the base station and control for using that information in the activation of the laser and servo motors. The actual implementation of these tasks rely on the same code presented in phase 1.\\nWe elected to sample our analog stick at approximately 60Hz. This was done based off the knowledge that responsive video games typically target 60 frames per second. We then match this rate in sending out the input information to the remote station. In retrospect, it would be worth investigating sampling at an even higher rate, and sending at the same or slightly slower rate. The logic being that the low pass filter we apply to our analog stick input would be most effective on an over sampled input.\\nOn the remote station we faced a number of issues actually receiving a message. We hypothesized that this was due to two core problems:\\nThe Bluetooth and/or UART pin on the board had a limited buffer which could overflow and produce unexpected results.\\nThe first byte sent by our base station did not always correspond to the first byte read by our remote station.\\n\\nPart of the reason these two problems caused us so much pain was that we had elected to communicate by sending a struct over Bluetooth. This meant that getting the correct values depended completely on byte order, unlike in something like a JSON encoding, where the relative position of data could be preserved.\\nWhen developing our solution, the first of these problems caused a number of strange behaviours, such as a massive delay between the initial push of the analog joystick and the servo activating, as well as the remote station randomly indicating it had been sent the done signal. These issues went away once we over sampled our Bluetooth signal (we landed at a rate of about 100Hz). This prevented the Bluetooth buffer from growing too large which caused delay, and upon overflow, incorrect values. Because we prevent our receive task from reading the next message until the servos have been given new values, we also had to have our control task update at a similarly high rate. In the future it may be worth exploring a slower control rate combined with aggregating received messages.\\nThe second issue of byte alignment we solved by developing a simple communication protocol.\\nCommunication Protocol\\nA struct was used to communicate our data over Bluetooth. We used a four byte header for alignment. Shown below are the definitions of the struct and relevant constants.\\n#define MESSAGE_HEADER ((u32) 0x04030201)\\n#define MESSAGE_DONE   0b00000001\\n#define MESSAGE_LASER  0b00000010\\n\\ntypedef struct Message Message;\\nstruct Message {\\n#ifdef MESSAGE_SENDER\\n    u32 header;\\n#endif\\n    s8 u_x;\\n    s8 u_y;\\n    s8 m_x;\\n    s8 m_y;\\n    u8 flags;\\n};\\nFor our data values we selected as efficient of integer types as reasonably possible. Our analog stick values come from fixed point calculations, meaning they are guaranteed to be between -128 and 127, which means a single signed byte is all that is needed to communicate each stick position. We send the done flag and laser state in a single shared byte, as this is the smallest reasonable encoding for that binary data.\\nThe 4-byte header provides a means of synchronizing the remote and base stations. Having the remote station wait until it has correctly read the header will help guarantee data correctness. We started with an 8-byte header that simply counted from 1 to 8. Immediately we ran into an issue of endianness, as a u64 of 0x0102030405060708 is actually encoded low byte first in memory on our boards. Since we were reading these bytes one at a time at the remote station we had to reverse the order of our header value. Once we had a working system we lowered the header down to 4 bytes and found there was no loss in correctness. More clever schemes for alignment could be devised. Two that we considered are as follows:\\nThe Bluetooth modules seems to provide a reliable connection, meaning we could attempt to synchronize only once at startup and then trust that we will receive every byte in alignment.\\nWe could use a single byte for alignment, such as 0xFF, and to ensure correctness enforce the policy that all fields of our message struct are never allowed to encode this value.\\n\\nUltimately,  we preferred our solution for its simplicity and reliability. In terms of implementing this protocol, the main work rested on the remote station. Its process of receiving bytes can be modeled using a simple state machine, shown below.\\nState Machine\\nThe four-byte header precedes each message. One drawback to this design is that if the remote station misses the header for any reason, that message will be skipped and the information will be lost. If the remote station successfully sees the header, the next five bytes it reads will be the message data, which it will subsequently map to servo positions and the laser state.\\nThe implementation of send for this protocol is provided below. We send the struct byte by byte over Bluetooth. If we assume our receiver will similarly copy our bytes into a buffer of the same type, this has the nice feature of not caring about endianness, so long as the client and host agree. \\nvoid send() {\\n    digitalWrite(LOGIC_SEND, HIGH);\\n    // Write each byte of current message onse at a time\\n    u8 * buffer = (u8 *) &amp;current_message;\\n    u16 i;\\n    for (i = 0; i &lt; sizeof(Message); i++) {\\n        Serial1.write(buffer[i]);\\n    }\\n    digitalWrite(LOGIC_SEND, LOW);\\n}\\nThe receive function is slightly more complex. First it must correctly implement the aforementioned state machine, as well as the function should not block if serial input from the Bluetooth is not available. The later issue is nicely resolved using static variables. For ease of implementation we generalize the first four states into a single handler.\\nvoid receive() {\\n\\n    static int i = 0;\\n    static int state = header1;\\n\\n    digitalWrite(LOGIC_RECEIVE, HIGH);\\n    if (current_message == NULL) {\\n        u8 * buffer = (u8 *) &amp;buffer_message;\\n        while (Serial1.available()) {\\n            switch(state) {\\n                case header1:\\n                case header2:\\n                case header3:\\n                case header4:\\n                    if (Serial1.read() == state) {\\n                        state++;\\n                    } else {\\n                        state = header1;\\n                    }\\n                    break;\\n                case data:\\n                    // Read as much as is available\\n                    while (Serial1.available()) {\\n                        buffer[i++] = Serial1.read();\\n                        if (i == sizeof(Message)) {\\n                            current_message = &amp;buffer_message;\\n                            state = header1;\\n                            i = 0;\\n                            digitalWrite(LOGIC_RECEIVE, LOW);\\n                            return;\\n                        }\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n    }\\n    digitalWrite(LOGIC_RECEIVE, LOW);\\n}\\nIt is worth noting that both functions above provide code for setting a pin high when the function is entered, and low when the function returns. This is used for observations using the logic analyzer in the following section.\\nCPU Utilization\\nTiming measurements were taken using both internal software and an external logic analyzer. Low CPU utilization is preferred in order to save power. In real world real-time systems, power consumption translates directly to cost. Additionally, low CPU utilization will allow for additional tasks in the project.\\nBase Station\\nThe base station&amp;#39;s two tasks, sample and send, were both set to run periodically every 16 milliseconds (approximately 60Hz). As previously mentioned, at the beginning of each task, a digital output pin was set to high, and at the end of each task that same pin was set to low. A Saleae logic analyzer was used to record these pin level changes and measure the durations of the two tasks. From the screenshot below, it can be seen that the time triggered scheduler does not guarantee precise periods. In this instance, the experimental periods of sample and send were 17.11ms and 16.08ms, respectively. \\nLogic 1\\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the sample task took 907 μs and the execution of the send task took 57.5 μs. It makes sense that sample takes longer because it has to obtain the state of multiple IO devices, as well as apply four low pass filters. In contrast, send simply has to send 9 bytes of data to the built-in UART.\\nFrom these measurements, the CPU utilization can be calculated as\\npercent used = ((Sample_duration / Sample_period) + (Send_duration / Send_period)) × 100%\\nUsing the measurements below, the CPU is in use 5.66% of the time. That translates to 94% idle time. Note that this is a rough value because of the inconsistency in the scheduler. A more accurate value could be estimated by averaging more samples from the logic analyzer.\\nLogic 2\\nRemote Station\\nThe remote station&amp;#39;s two tasks, control and receive, were both set to run periodically every 10 milliseconds (approximately 100Hz).  As explained above, the higher frequency of the remote station tasks versus the base station tasks ensured an acceptable level of responsiveness in the IO devices and prevented the Bluetooth buffer from filling up.\\nDepicted below, the experimental periods of control and receive were 9.343ms and 10.16ms, respectively. \\nLogic 3\\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the control task took 193 μs and the execution of the receive task took 55 μs. It makes sense that control takes longer because it has to adjust the state of multiple IO devices, whereas receive simply has to read from the UART. It is also worth noting that the computation time of control varies significantly. This is because on some calls the servo is not ready to receive a new position, which decreases the computation cost significantly. \\nUsing the same equation as above, and the measurements listed below, CPU utilization was found to be 2.61%, which translates to roughly 97% idle time. \\nLogic 4\\nWe also measured our percentage of idle time in software. We used a simple process to determine this.\\nWe recorded the time in milliseconds prior to entering the main loop.\\nEach time the time triggered scheduler returns with an idle time duration we add it to an ongoing sum.\\nWhen we exit the main loop we record the end time in milliseconds.\\nWe calculated idle percentage as:\\n\\npercent idle = idle time / (start time - end time) × 100%\\nUsing this measurement method, we found that on average our base station was idle 93% of the time and our remote station was idle 98% of the time. These correlate closely with the results obtained from the logic analyzer (94% and 97%). Looking at our logical analyzer results it is clear that sampling inputs and controlling the servos is taking up the large majority of the processing time. If we wanted to improve our CPU utilization, this would be our starting point.\\nConclusion\\nNow that we have completed project 1 we are preparing and planning for project 2 where we will expand upon our current TTA, developing it into our own simple real-time operating system.\\nReferences\\n[1] M. Cheng, &amp;quot;Project 3&amp;quot;, Webhome.csc.uvic.ca, 2019. [Online]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. [Accessed: Apr-2019].\\n[2] E. Hughes, &amp;quot;Introduction to Fixed Point Math&amp;quot;, 2014. [Online]. Available: https://www.youtube.com/watch?v=bbFBgXndmP0. [Accessed: Apr-2019].\\n',\n        route: '/blog/rtos1',\n        layout: '../../layouts/Blog',\n        title: 'Creating an RTOS (Pt. 1)',\n        subtitle: 'Exploring a Time Triggered Scheduler using Arduino and finding the usecase for a barebones RTOS',\n        blog: true,\n        date: '05-18-2019',\n    }),\n    siteHistory: new Page({\n        name: 'siteHistory',\n        content: '',\n        plainTxt: '',\n        route: '/blog/siteHistory',\n        layout: '../../layouts/Blog',\n        title: 'Site History',\n        subtitle: 'A look at the technologies used to build this site, and its past iteration.',\n        blog: true,\n        date: '05-16-2019',\n    }),\n    index: new Page({\n        name: 'index',\n        content: '',\n        plainTxt: '',\n        route: '/index',\n        title: 'ejrbuss.net',\n        layout: '../layouts/Home',\n    }),\n    work: new Page({\n        name: 'work',\n        content: '',\n        plainTxt: '',\n        route: '/work',\n        layout: '../layouts/Work',\n        title: 'Work',\n        projects: [\n            {\n                logo: 'TypeMark',\n                title: 'type-mark',\n                href: 'http://ejrbuss.net/type-mark/',\n                summary: 'A runtime type-checking library for JavaScript that supports complex predicates and object inerfaces. Heavily extendable by the user. Available through npm.',\n            },\n            {\n                logo: 'Mekpie',\n                title: 'Mekpie',\n                href: 'https://ejrbuss.net/mekpie/',\n                summary: 'An opinionated build system for small scale C projects, written and configured using Python. Available through pip.',\n            },\n            {\n                logo: 'DndInitTracker',\n                title: 'D&D Initiative Tracker',\n                href: 'https://ejrbuss.net/dnd-initiative-tracker/',\n                summary: 'A tool to help Dungeon Masters manage players and enemies when playing Dungeons and Dragons. Visit the site and step up your game.',\n            },\n            {\n                logo: 'IndiGo',\n                title: 'indiGO',\n                href: 'https://ejrbuss.net/go',\n                summary: \"A webapp of the game Go made by a team of software engineering sudents at the University of Victoria. I was in charge of the front end design and am still proud of the game's persona-esque aesthetic.\",\n            },\n            {\n                logo: 'Ejrbuss',\n                title: 'ejrbuss.net',\n                href: '',\n                summary: 'This website has gone through redevelopment a few times over the years. Read about past mistakes here.',\n            },\n        ],\n        work: [\n            {\n                logo: 'UofA',\n                title: 'UofA Engineering Department',\n                href: '',\n                summary: \"I worked 8 months at the University of Alberta on two seperate coops. I got to work one-on-one with a Mechanical Engineering Professor as well as help maintain the engineering department's intranet.\",\n            },\n            {\n                logo: 'Ericsson',\n                title: 'Ericsson',\n                href: '',\n                summary: \"I worked as an iOS and web developer coop for 8 months at Ericsson's Ottawa site. I got to work on a diverse and distributed team of engineers.\",\n            },\n        ],\n    }),\n    rtos2: new Page({\n        name: 'rtos2',\n        content: '> # Author\\'s Note\\n>\\n> *This blog post is part one in a series originally put together for the University of Victoria\\'s CSC 460 course. The original content was publishd March 13 2019 by [Torrey Randolph](https://github.com/torreyr) and myself. As that webpage no longer exists I am now hosting the content here.*\\n\\n# Introduction \\n\\nThe goal of project 2 was to design and implement a real time operating system (RTOS) and a corresponding API to be used in the final project, project 3. The RTOS created for this project is an extension of a time-triggered architecture (TTA) scheduler, with some important new features including support for non-periodic tasks as well as multiple instances of the same task. Many design decisions had to be made including how to represent tasks, what scheduling algorithm to use, and how to keep track of time. These will be described in more detail in the sections below. This report will also cover the strategies used to test our implementation and some hardships we came across during the process.\\n\\nThe only special hardware needed for this project was a single Arduino Mega 2560 board and a Saleae USB logic analyzer. Software dependencies are the same as in project 1, they can be seen listed [here](/blog/rtos1).\\n\\n# RTOS\\n\\n## Overview\\n\\nThe simplicity of a TTA lends itself to a simple API, we wanted our RTOS keep this quality. TTA implementations are broken into two phases: a declarative phase, where tasks are defined for the scheduler, and a run phase, or runtime phase, where the scheduler manages the task. What makes our solution truly an RTOS and not just a scheduler is our emphasis on that runtime phase. This will become especially clear when we discuss our much more dynamic conception of tasks when compared to a standard TTA implementation. This focus also influenced our core API and what services we wanted to provide the user beyond simply calling a function at the right time, namely we built the RTOS from the ground up with instrumentation in mind and placed an emphasis on improving the debug experience of lower level C development. The following is a condensed overview of the RTOS API.\\n\\n```lang:c++-readonly\\nnamespace RTOS {\\n  \\n    void init();\\n    void dispatch();\\n    void halt();\\n    void trace();\\n    void error();\\n    void debug_print(const char * fmt, ...);\\n    void debug_led(bool led);\\n  \\n    namespace Registers {\\n        extern Event_t triggers;\\n    }\\n  \\n    namespace UDF {\\n        void trace(Trace_t * trace);\\n        bool error(Trace_t * trace);\\n    }\\n}\\n```\\n\\nThe functions init, dispatch, and halt are all essential to the basic operation of the RTOS, taking the responsibility of initializing resources, starting scheduling, and safely shutting down the RTOS respectively. We were selective about what C++ features we wanted to take advantage of for the RTOS, but namespaces were one we decided to capitalize on. Outside of simply helping avoid name collisions, namespaces serve our design to organize more traditional procedural programming constructs into something more familiar to programmers who have seen object oriented interfaces. \\n\\nThe functions trace and error allow both the internals of the RTOS, and user programs to efficiently communicate information with the developer. This could be scheduling information, debug messages, or runtime checks. How these functions works, along with their sister functions in the User Defined Function (UDF) namespace is detailed in the Tracing section of the report.\\n\\nOutside of these functions, the core functionality of the RTOS involves Tasks.\\n\\n## Tasks\\n\\nIn a standard TTA tasks are defined by an implementation, commonly a function, a period, and an offset. Our RTOS includes these properties and more in order to extend the functionality of a TTA. The comprehensive set of properties are viewable as the fields in the Task_t struct:\\n\\n```lang:c++-readonly\\nstruct Task_t {\\n    task_fn_t fn;   // A pointer to the task funtion\\n    void * state;   // A pointer to the task\\'s associated state\\n    Event_t events; // The events that cause this task to be scheduled\\n    i16 period_ms;  // The schedule period of this task (in milliseconds)\\n    i16 delay_ms;   // The delay before this task is scheduled\\n    // \"hidden\" fields\\n    struct {\\n        bool first;\\n        u8 instance; // Used to identify a task during a trace\\n        i64 last;    // The last time this task was run\\n        i16 maximum; // The maximum runtime of this task so far\\n    } impl;\\n};\\n```\\n\\nThe final three fields of the Task are meant to be used only by the RTOS for bookkeeping. The fields work as follows:\\n\\n - `fn`: Like in TTA this defines the implementation, a function pointer that will run every time the task is scheduled. These functions are provided their containing Task_t struct as an argument allowing them to self modify and mutate. Additionally, we allow this function to determine whether the Task should be run again by returning a boolean result.\\n - `state`: Providing room in Task_t for the user to store an arbitrary pointer allows for instancing of tasks. This is discussed in more detail later in the report.\\nevents: We provide a mechanism for reactive computation by way of event-driven tasks. The events field of Task_t define what events a Task responds to.\\n - `period_ms`: The period is a standard field needed for a periodic TTA. Our RTOS provides accurate scheduling up to one ms.\\ndelay_ms: Similar to period, delay is another standard field needed for TTA in order to offset Tasks from one another.\\n - `first`: Some behaviour of Tasks depends on whether it is being run for the first time. For instance a periodic time without delay will be run at time 0. \\ninstance: In order to efficiently trace a Task schedule we want to be able to identify a Task by a unique identifier. We reserve one byte to indicate the Task instance. This is not referring to the type of instancing provided by the state field, this instance refers to every instance of Task that exists in the system.\\n - `last`: This field records the last time this Task was run allowing the RTOS to easily calculate its next run time.\\n - `maximum`: This field records the longest time this Task has ever taken to run. For standard periodic tasks this does not impact the Task\\'s execution, but for less essential Tasks this gives the RTOS the ability to make a reasonable guess as to whether a Task can fit into an idle gap.\\n\\nA  key design decision in our RTOS is to represent all types of Tasks with a single construct. A Task is dispatched to the RTOS in two situations. First explicitly, when the user defines the task and then calls Task::dispatch. Second automatically, after a task is run it is reconsidered by the RTOS. This means that a task function can modify its associated Task_t struct in anyway it sees fit, allowing one type of task to become any other type of task. Additionally, tasks can be freely created and destroyed as the RTOS is running, simply by calling the appropriate functions from a task function.\\n\\nThis high level of dynamism means that the RTOS needs to support quick allocation and deallocation of Tasks as well as efficient means of bookkeeping different task types. Rather than depending on the heavyweight solution of malloc and free, we utilize a generic Memory Pool allocator (also sometimes referred to as a refrigerator allocator) to solve both of these problems. Memory Pool allocators can refer to slightly different systems depending on where you look. Our solution focuses on the allocation of like-sized memory chunks. We divide a region of memory into equal size chunks. Each chunk has enough room for the desired object and a pointer to another chunk. By chaining theses chunk pointers together we effectively create a linked list of available chunks. Figure 1 below helps illustrate this setup.\\n\\n![Memory Pool Layout](/static/blog/rtos2/memory-pool-layout.png)\\n\\nAllocating memory is as simple as popping the head off the list, and deallocating memory is as simple as prepending a chunk back on to the list. This allocation scheme is significantly simpler and faster than more generic allocation schemes, it also has a hidden benefit. When a chunk is allocated its associated chunk pointer is no longer being used by the allocator, this leaves it free to be used to help construct new linked list structures. This is the methodology used by the RTOS for task allocation and management.  Tasks are allocated using a Memory Pool, and then organized into linked lists using their associated chunk pointers.\\n\\n## Periodic Tasks\\n\\nPeriodic tasks are time-sensitive tasks that the RTOS aims to always run on time. The are the highest possible priority task. A periodic task is defined by its period and delay. The delay of a periodic task acts as its offset, determining how much time occurs between the task being created and being run. Dynamically created periodic tasks measure their start time from the scheduled time of the task that created them. The scheduled time of a task is the theoretically best time a task would run, not its actual time. This means that if there is a periodic task that dynamically creates another periodic task, that task will still run at the expected time.\\n\\nThe following is an example of creating a periodic task:\\n\\n```lang:c++-readonly\\nusing namespace RTOS;\\n\\nTask_t * my_task = Task::init(\"my_task\", my_task_fn);\\nmy_task->period_ms = 1000;\\nmy_task->delay_ms  = 500;\\nTask::dispatch(my_task);\\n```',\n        plainTxt: 'Author&amp;#39;s Note\\nThis blog post is part one in a series originally put together for the University of Victoria&amp;#39;s CSC 460 course. The original content was publishd March 13 2019 by Torrey Randolph and myself. As that webpage no longer exists I am now hosting the content here.\\n\\nIntroduction\\nThe goal of project 2 was to design and implement a real time operating system (RTOS) and a corresponding API to be used in the final project, project 3. The RTOS created for this project is an extension of a time-triggered architecture (TTA) scheduler, with some important new features including support for non-periodic tasks as well as multiple instances of the same task. Many design decisions had to be made including how to represent tasks, what scheduling algorithm to use, and how to keep track of time. These will be described in more detail in the sections below. This report will also cover the strategies used to test our implementation and some hardships we came across during the process.\\nThe only special hardware needed for this project was a single Arduino Mega 2560 board and a Saleae USB logic analyzer. Software dependencies are the same as in project 1, they can be seen listed here.\\nRTOS\\nOverview\\nThe simplicity of a TTA lends itself to a simple API, we wanted our RTOS keep this quality. TTA implementations are broken into two phases: a declarative phase, where tasks are defined for the scheduler, and a run phase, or runtime phase, where the scheduler manages the task. What makes our solution truly an RTOS and not just a scheduler is our emphasis on that runtime phase. This will become especially clear when we discuss our much more dynamic conception of tasks when compared to a standard TTA implementation. This focus also influenced our core API and what services we wanted to provide the user beyond simply calling a function at the right time, namely we built the RTOS from the ground up with instrumentation in mind and placed an emphasis on improving the debug experience of lower level C development. The following is a condensed overview of the RTOS API.\\nnamespace RTOS {\\n\\n    void init();\\n    void dispatch();\\n    void halt();\\n    void trace();\\n    void error();\\n    void debug_print(const char * fmt, ...);\\n    void debug_led(bool led);\\n\\n    namespace Registers {\\n        extern Event_t triggers;\\n    }\\n\\n    namespace UDF {\\n        void trace(Trace_t * trace);\\n        bool error(Trace_t * trace);\\n    }\\n}\\nThe functions init, dispatch, and halt are all essential to the basic operation of the RTOS, taking the responsibility of initializing resources, starting scheduling, and safely shutting down the RTOS respectively. We were selective about what C++ features we wanted to take advantage of for the RTOS, but namespaces were one we decided to capitalize on. Outside of simply helping avoid name collisions, namespaces serve our design to organize more traditional procedural programming constructs into something more familiar to programmers who have seen object oriented interfaces. \\nThe functions trace and error allow both the internals of the RTOS, and user programs to efficiently communicate information with the developer. This could be scheduling information, debug messages, or runtime checks. How these functions works, along with their sister functions in the User Defined Function (UDF) namespace is detailed in the Tracing section of the report.\\nOutside of these functions, the core functionality of the RTOS involves Tasks.\\nTasks\\nIn a standard TTA tasks are defined by an implementation, commonly a function, a period, and an offset. Our RTOS includes these properties and more in order to extend the functionality of a TTA. The comprehensive set of properties are viewable as the fields in the Task_t struct:\\nstruct Task_t {\\n    task_fn_t fn;   // A pointer to the task funtion\\n    void * state;   // A pointer to the task&#39;s associated state\\n    Event_t events; // The events that cause this task to be scheduled\\n    i16 period_ms;  // The schedule period of this task (in milliseconds)\\n    i16 delay_ms;   // The delay before this task is scheduled\\n    // &quot;hidden&quot; fields\\n    struct {\\n        bool first;\\n        u8 instance; // Used to identify a task during a trace\\n        i64 last;    // The last time this task was run\\n        i16 maximum; // The maximum runtime of this task so far\\n    } impl;\\n};\\nThe final three fields of the Task are meant to be used only by the RTOS for bookkeeping. The fields work as follows:\\nfn: Like in TTA this defines the implementation, a function pointer that will run every time the task is scheduled. These functions are provided their containing Task_t struct as an argument allowing them to self modify and mutate. Additionally, we allow this function to determine whether the Task should be run again by returning a boolean result.\\nstate: Providing room in Task_t for the user to store an arbitrary pointer allows for instancing of tasks. This is discussed in more detail later in the report.\\nevents: We provide a mechanism for reactive computation by way of event-driven tasks. The events field of Task_t define what events a Task responds to.\\nperiod_ms: The period is a standard field needed for a periodic TTA. Our RTOS provides accurate scheduling up to one ms.\\ndelay_ms: Similar to period, delay is another standard field needed for TTA in order to offset Tasks from one another.\\nfirst: Some behaviour of Tasks depends on whether it is being run for the first time. For instance a periodic time without delay will be run at time 0. \\ninstance: In order to efficiently trace a Task schedule we want to be able to identify a Task by a unique identifier. We reserve one byte to indicate the Task instance. This is not referring to the type of instancing provided by the state field, this instance refers to every instance of Task that exists in the system.\\nlast: This field records the last time this Task was run allowing the RTOS to easily calculate its next run time.\\nmaximum: This field records the longest time this Task has ever taken to run. For standard periodic tasks this does not impact the Task&amp;#39;s execution, but for less essential Tasks this gives the RTOS the ability to make a reasonable guess as to whether a Task can fit into an idle gap.\\n\\nA  key design decision in our RTOS is to represent all types of Tasks with a single construct. A Task is dispatched to the RTOS in two situations. First explicitly, when the user defines the task and then calls Task::dispatch. Second automatically, after a task is run it is reconsidered by the RTOS. This means that a task function can modify its associated Task_t struct in anyway it sees fit, allowing one type of task to become any other type of task. Additionally, tasks can be freely created and destroyed as the RTOS is running, simply by calling the appropriate functions from a task function.\\nThis high level of dynamism means that the RTOS needs to support quick allocation and deallocation of Tasks as well as efficient means of bookkeeping different task types. Rather than depending on the heavyweight solution of malloc and free, we utilize a generic Memory Pool allocator (also sometimes referred to as a refrigerator allocator) to solve both of these problems. Memory Pool allocators can refer to slightly different systems depending on where you look. Our solution focuses on the allocation of like-sized memory chunks. We divide a region of memory into equal size chunks. Each chunk has enough room for the desired object and a pointer to another chunk. By chaining theses chunk pointers together we effectively create a linked list of available chunks. Figure 1 below helps illustrate this setup.\\nMemory Pool Layout\\nAllocating memory is as simple as popping the head off the list, and deallocating memory is as simple as prepending a chunk back on to the list. This allocation scheme is significantly simpler and faster than more generic allocation schemes, it also has a hidden benefit. When a chunk is allocated its associated chunk pointer is no longer being used by the allocator, this leaves it free to be used to help construct new linked list structures. This is the methodology used by the RTOS for task allocation and management.  Tasks are allocated using a Memory Pool, and then organized into linked lists using their associated chunk pointers.\\nPeriodic Tasks\\nPeriodic tasks are time-sensitive tasks that the RTOS aims to always run on time. The are the highest possible priority task. A periodic task is defined by its period and delay. The delay of a periodic task acts as its offset, determining how much time occurs between the task being created and being run. Dynamically created periodic tasks measure their start time from the scheduled time of the task that created them. The scheduled time of a task is the theoretically best time a task would run, not its actual time. This means that if there is a periodic task that dynamically creates another periodic task, that task will still run at the expected time.\\nThe following is an example of creating a periodic task:\\nusing namespace RTOS;\\n\\nTask_t * my_task = Task::init(&quot;my_task&quot;, my_task_fn);\\nmy_task-&gt;period_ms = 1000;\\nmy_task-&gt;delay_ms  = 500;\\nTask::dispatch(my_task);\\n',\n        route: '/blog/rtos2',\n        layout: '../../layouts/Blog',\n        title: 'Creating an RTOS (Pt. 2)',\n        subtitle: 'Designing and implementing a RTOS based on a Time Triggered Architecturee',\n        blog: true,\n        date: '05-19-2019',\n    }),\n\n};\n"],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AADA;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AA9CA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AApIA;;;;A","sourceRoot":""}