<!DOCTYPE html><html><head><title class="next-head">Creating an RTOS (Pt. 2)</title><meta charSet="UTF-8" class="next-head"/><meta name="description" content="" class="next-head"/><meta name="keywords" content="" class="next-head"/><meta name="author" content="Eric Buss" class="next-head"/><meta name="viewport" content="width=device-width, initial-scale=1.0" class="next-head"/><link rel="shortcut icon" href="/static/favicon.ico" class="next-head"/><link rel="stylesheet" href="/static/css/github.css" class="next-head"/><link rel="stylesheet" href="/static/css/spectre.min.css" class="next-head"/><link rel="stylesheet" href="/static/css/spectre-exp.min.css" class="next-head"/><link rel="stylesheet" href="/static/css/font-awesome.min.css" class="next-head"/><link rel="stylesheet" href="/static/css/animate.css" class="next-head"/><script src="/static/js/es5-shim.min.js" class="next-head"></script><script src="/static/js/es6-shim.min.js" class="next-head"></script><script src="/static/js/object-shim.js" class="next-head"></script><link rel="preload" href="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/blog/creating-an-rtos-pt-2.js" as="script"/><link rel="preload" href="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/_error.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-f4542de9ce6104e90191.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2ccf073e64d3d8a62c5c.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-98aa4765ad2a12a28472.js" as="script"/><link rel="stylesheet" href="/_next/static/css/commons.eed36b44.chunk.css"/></head><body><div id="__next"><div id="page"><header class="navbar"><div class="scroll-marker" style="width:NaN%"></div><section class="navbar-section container grid-md"><a class="navbar-brand m-lg ml-clr" href="/index/"><div class="logo"><svg style="width:40px;height:40px" class="logo" viewBox="0 0 11 11" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M2 1 V10 H10 V2 H6 V7" stroke="rgb(0, 0, 0)" stroke-width="2" fill="transparent"></path><path class="path" d="M2 1 V10 H10 V2 H6 V7" stroke="rgb(244, 66, 55)" stroke-width="2.3" fill="transparent"></path></svg></div></a><a class="m-md slide " href="/work/">WORK</a><a class="m-md slide " href="/about/">ABOUT</a><a class="m-md slide active" href="/blog/">BLOG</a><div class="fill-width"><div class="float-right hide-xs text-sm center"><input type="text" placeholder="Type to search..." value="" class="closed"/><a class="p-md subtle-accent"><i class="fas fa-search fa-lg"></i></a><a target="_blank" href="https://github.com/ejrbuss" class="p-md subtle-accent"><i class="fab fa-github fa-lg"></i></a></div><div class="search hide-xs text-sm "></div></div></section></header><div class="side-nav hide-xl"><ul class="nav outer d-inline-block text-left"></ul></div><div class="search-results"><div class="container grid-md"></div></div><div class="content container grid-md"><h1 class="title">Creating an RTOS (Pt. 2)</h1><p class="cslr-subtext text-lg">Designing and implementing a RTOS based on a Time Triggered Architecture</p><p class="subtext"><a class="anchor"><i class="far fa-calendar"></i> <!-- -->May 19 2019</a></p><div class="md indexable"><blockquote><a class="anchor-point" id="author&#x27;snote"></a><a class="anchor" href="#author&#x27;snote"><h1>Author&#x27;s Note</h1><br/></a><p><em>This blog post is part two in a series originally put together for the University of Victoria&#x27;s CSC 460 course. The original content was published March 13 2019 by <a href="https://github.com/torreyr">Torrey Randolph</a> and myself. As that webpage no longer exists I am now hosting the content here.</em></p><p><em>Here are links to <a href="/blog/rtos1">part 1</a> and <a href="/blog/rtos3">part 3</a>.</em></p></blockquote><a class="anchor-point" id="introduction"></a><a class="anchor" href="#introduction"><h1>Introduction</h1><br/></a><p>The goal of project 2 was to design and implement a real time operating system (RTOS) and a corresponding API to be used in the final project, project 3. The RTOS created for this project is an extension of a time-triggered architecture (TTA) scheduler, with some important new features including support for non-periodic tasks as well as multiple instances of the same task. Many design decisions had to be made including how to represent tasks, what scheduling algorithm to use, and how to keep track of time. These will be described in more detail in the sections below. This report will also cover the strategies used to test our implementation and some hardships we came across during the process.</p><p>The only special hardware needed for this project was a single Arduino Mega 2560 board and a Saleae USB logic analyzer. Software dependencies are the same as in project 1, they can be seen listed <a href="/blog/rtos1">here</a>.</p><a class="anchor-point" id="rtos"></a><a class="anchor" href="#rtos"><h1>RTOS</h1><br/></a><a class="anchor-point" id="overview"></a><a class="anchor" href="#overview"><h2>Overview</h2><br/></a><p>The simplicity of a TTA lends itself to a simple API, we wanted our RTOS keep this quality. TTA implementations are broken into two phases: a declarative phase, where tasks are defined for the scheduler, and a run phase, or runtime phase, where the scheduler manages the task. What makes our solution truly an RTOS and not just a scheduler is our emphasis on that runtime phase. This will become especially clear when we discuss our much more dynamic conception of tasks when compared to a standard TTA implementation. This focus also influenced our core API and what services we wanted to provide the user beyond simply calling a function at the right time, namely we built the RTOS from the ground up with instrumentation in mind and placed an emphasis on improving the debug experience of lower level C development. The following is a condensed overview of the RTOS API.</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span></div><div class="text"><pre><span class="hljs-keyword">namespace</span> RTOS {
  
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">halt</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trace</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debug_print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * fmt, ...)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debug_led</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> led)</span></span>;
  
    <span class="hljs-keyword">namespace</span> Registers {
        <span class="hljs-keyword">extern</span> Event_t triggers;
    }
  
    <span class="hljs-keyword">namespace</span> UDF {
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trace</span><span class="hljs-params">(Trace_t * trace)</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">error</span><span class="hljs-params">(Trace_t * trace)</span></span>;
    }
}</pre></div></div></div><p>The functions init, dispatch, and halt are all essential to the basic operation of the RTOS, taking the responsibility of initializing resources, starting scheduling, and safely shutting down the RTOS respectively. We were selective about what C++ features we wanted to take advantage of for the RTOS, but namespaces were one we decided to capitalize on. Outside of simply helping avoid name collisions, namespaces serve our design to organize more traditional procedural programming constructs into something more familiar to programmers who have seen object oriented interfaces. </p><p>The functions trace and error allow both the internals of the RTOS, and user programs to efficiently communicate information with the developer. This could be scheduling information, debug messages, or runtime checks. How these functions works, along with their sister functions in the User Defined Function (UDF) namespace is detailed in the Tracing section of the report.</p><p>Outside of these functions, the core functionality of the RTOS involves Tasks.</p><a class="anchor-point" id="tasks"></a><a class="anchor" href="#tasks"><h2>Tasks</h2><br/></a><p>In a standard TTA tasks are defined by an implementation, commonly a function, a period, and an offset. Our RTOS includes these properties and more in order to extend the functionality of a TTA. The comprehensive set of properties are viewable as the fields in the Task_t struct:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span></div><div class="text"><pre><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task_t</span> {</span>
    <span class="hljs-keyword">task_fn_t</span> fn;   <span class="hljs-comment">// A pointer to the task funtion</span>
    <span class="hljs-keyword">void</span> * state;   <span class="hljs-comment">// A pointer to the task's associated state</span>
    Event_t events; <span class="hljs-comment">// The events that cause this task to be scheduled</span>
    i16 period_ms;  <span class="hljs-comment">// The schedule period of this task (in milliseconds)</span>
    i16 delay_ms;   <span class="hljs-comment">// The delay before this task is scheduled</span>
    <span class="hljs-comment">// "hidden" fields</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        <span class="hljs-keyword">bool</span> first;
        u8 instance; <span class="hljs-comment">// Used to identify a task during a trace</span>
        i64 last;    <span class="hljs-comment">// The last time this task was run</span>
        i16 maximum; <span class="hljs-comment">// The maximum runtime of this task so far</span>
    } impl;
};</pre></div></div></div><p>The final three fields of the Task are meant to be used only by the RTOS for bookkeeping. The fields work as follows:</p><ul><li><code>fn</code>: Like in TTA this defines the implementation, a function pointer that will run every time the task is scheduled. These functions are provided their containing Task_t struct as an argument allowing them to self modify and mutate. Additionally, we allow this function to determine whether the Task should be run again by returning a boolean result.</li><li><code>state</code>: Providing room in Task_t for the user to store an arbitrary pointer allows for instancing of tasks. This is discussed in more detail later in the report.
events: We provide a mechanism for reactive computation by way of event-driven tasks. The events field of Task_t define what events a Task responds to.</li><li><code>period_ms</code>: The period is a standard field needed for a periodic TTA. Our RTOS provides accurate scheduling up to one ms.
delay_ms: Similar to period, delay is another standard field needed for TTA in order to offset Tasks from one another.</li><li><code>first</code>: Some behaviour of Tasks depends on whether it is being run for the first time. For instance a periodic time without delay will be run at time 0. 
instance: In order to efficiently trace a Task schedule we want to be able to identify a Task by a unique identifier. We reserve one byte to indicate the Task instance. This is not referring to the type of instancing provided by the state field, this instance refers to every instance of Task that exists in the system.</li><li><code>last</code>: This field records the last time this Task was run allowing the RTOS to easily calculate its next run time.</li><li><code>maximum</code>: This field records the longest time this Task has ever taken to run. For standard periodic tasks this does not impact the Task&#x27;s execution, but for less essential Tasks this gives the RTOS the ability to make a reasonable guess as to whether a Task can fit into an idle gap.</li></ul><p>A  key design decision in our RTOS is to represent all types of Tasks with a single construct. A Task is dispatched to the RTOS in two situations. First explicitly, when the user defines the task and then calls Task::dispatch. Second automatically, after a task is run it is reconsidered by the RTOS. This means that a task function can modify its associated Task_t struct in anyway it sees fit, allowing one type of task to become any other type of task. Additionally, tasks can be freely created and destroyed as the RTOS is running, simply by calling the appropriate functions from a task function.</p><p>This high level of dynamism means that the RTOS needs to support quick allocation and deallocation of Tasks as well as efficient means of bookkeeping different task types. Rather than depending on the heavyweight solution of malloc and free, we utilize a generic Memory Pool allocator (also sometimes referred to as a refrigerator allocator) to solve both of these problems. Memory Pool allocators can refer to slightly different systems depending on where you look. Our solution focuses on the allocation of like-sized memory chunks. We divide a region of memory into equal size chunks. Each chunk has enough room for the desired object and a pointer to another chunk. By chaining theses chunk pointers together we effectively create a linked list of available chunks. Figure 1 below helps illustrate this setup.</p><p><img alt="Memory Pool Layout" src="/static/blog/rtos2/memory-pool-layout.png"/></p><p>Allocating memory is as simple as popping the head off the list, and deallocating memory is as simple as prepending a chunk back on to the list. This allocation scheme is significantly simpler and faster than more generic allocation schemes, it also has a hidden benefit. When a chunk is allocated its associated chunk pointer is no longer being used by the allocator, this leaves it free to be used to help construct new linked list structures. This is the methodology used by the RTOS for task allocation and management.  Tasks are allocated using a Memory Pool, and then organized into linked lists using their associated chunk pointers.</p><a class="anchor-point" id="periodictasks"></a><a class="anchor" href="#periodictasks"><h2>Periodic Tasks</h2><br/></a><p>Periodic tasks are time-sensitive tasks that the RTOS aims to always run on time. The are the highest possible priority task. A periodic task is defined by its period and delay. The delay of a periodic task acts as its offset, determining how much time occurs between the task being created and being run. Dynamically created periodic tasks measure their start time from the scheduled time of the task that created them. The scheduled time of a task is the theoretically best time a task would run, not its actual time. This means that if there is a periodic task that dynamically creates another periodic task, that task will still run at the expected time.</p><p>The following is an example of creating a periodic task:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span></div><div class="text"><pre><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> RTOS;

Task_t * my_task = Task::init(<span class="hljs-string">"my_task"</span>, my_task_fn);
my_task-&gt;period_ms = <span class="hljs-number">1000</span>;
my_task-&gt;delay_ms  = <span class="hljs-number">500</span>;
Task::dispatch(my_task);</pre></div></div></div><a class="anchor-point" id="delayedtasks"></a><a class="anchor" href="#delayedtasks"><h2>Delayed Tasks</h2><br/></a><p>Delayed tasks are another form of time-sensitive tasks. Delayed tasks were added to the TTA to provide a clear method of declaring a &quot;one-shot&quot; task, ie. a task that is run only once. Our implementation of delayed tasks is more flexible however. A delayed task will be run jut once only if no new delay is supplied, or the task function itself returns false. This allows for a delayed task to be run an arbitrary number of times, waiting on a condition for instance, or run with different delays each time. </p><p>Delayed tasks are created in the same manner as periodic tasks, only their period_ms field is left at 0. </p><a class="anchor-point" id="eventdriventasks"></a><a class="anchor" href="#eventdriventasks"><h2>Event Driven Tasks</h2><br/></a><p>Event driven tasks provide a way for our RTOS to respond to urgent events, such as an interrupt occurring.  Our RTOS allows interrupts to occur at most times, specifically interrupts can occur during the run time of any task as well as during idle time. This opens up our design to race-conditions. To avoid these painful issues we allow interrupts to only do two things: read arbitrary data and dispatch an event. There is no strict check to ensure that the user does not violate this rule, so it is on them to ensure their program upholds this convention. Event code is carefully written to allow read and writing from interrupts, disabling interrupts at key points in time if necessary.</p><p>Events in our system are represented as bits at a specific memory location. The definition for events is provided below:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span></div><div class="text"><pre><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NUMTYPE_U</span><span class="hljs-params">(RTOS_MAX_EVENTS)</span> Event_t</span>;

<span class="hljs-keyword">namespace</span> Event {
    <span class="hljs-function">Event_t <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * handle)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(Event_t e)</span></span>;
}</pre></div></div></div><p>The number of bytes used for events depends on the desired maximum allowed events. We allow for 8, 16, 32, and 64 events corresponding to the different integer sizes. The Event API is limited to two functions, one for creating events and another for dispatching them. Internally the RTOS uses a variable to represent dispatched events. This variable is never read from or written to without first disabling interrupts.</p><p>In order for events to be useful tasks need to be able to respond to them. If a task has no delay and no period than it is allowed to become an event-driven task. A task sets its event field with the bits corresponding to the events it wants to listen to. When that even fires it will be scheduled in the next available idle gap, so long as no delayed task is waiting to run.</p><p>Each event can only drive a single task, but a task can listen to multiple events. When an event-driven task is run a the RTOS::Registers::triggered variable stores what tasks triggered the task to run. After running the event is considered cleared and will not trigger the task again until the event is dispatched again.</p><p>The following is an example of creating an event-driven task that listens for two different events:</p><div class="editor"><div class="code" data-lang="cc++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span></div><div class="text"><pre>using namespace RTOS;

Event_t event_1 = Event::init(&quot;event_1&quot;);
Event_t event_2 = Event::init(&quot;event_2&quot;);

Task_t * my_task = Task::init(&quot;my_task&quot;, my_task_fn);
my_task-&gt;events = event_1 | event_2;
Task::dispatch(my_task);</pre></div></div></div><a class="anchor-point" id="keepingstate"></a><a class="anchor" href="#keepingstate"><h2>Keeping State</h2><br/></a><p>In a normal TTA, each run of a task is a new activation of that task; tasks have no way to keep track of their history, or their state. This also means that two tasks with the same task function will have the same effect. By providing a pointer for state on Task_t we allow tasks to maintain state and have a notion of different instances.</p><a class="anchor-point" id="keepingtime"></a><a class="anchor" href="#keepingtime"><h2>Keeping Time</h2><br/></a><p>Time is an important part of a real time operating system. The operating system has to have a concept of time, however that is implemented. Our RTOS uses a hardware timer set to interrupt every millisecond to keep track of the current time. This timer increments a global variable representing the time in milliseconds since the RTOS was dispatched. Two factors had to be considered while developing this system: the precision of the timer and the size of our variable.</p><p>The crystal oscillator on the ATMega2560 runs at 16 MHz. Hardware timers can be configured to use the CPU clock directly or to use a scaled version of that clock. We configured Timer/Counter 1 on the ATMega2560 to use a clock with one-64th the frequency of the CPU clock. This, along with its interrupt set to trigger when the counter reached 250, produced a timer interrupt that went off every one millisecond. One millisecond precision was found to be enough for our system, providing us decent precision while limiting the CPU time spent updating our global time variable.</p><p>When deciding what size of variable to use, we calculated how long various sizes would take to overflow. Only signed integers were considered because the time is used in many arithmetic computations. With a 32-bit field, the largest number that can be represented is 2,147,483,647. That equates to 24 days of time-keeping before our variable would overflow. While that would be sufficient for the purposes of this project, we decided to instead use a signed 64-bit field, giving us roughly 292 years of time-keeping ability.</p><a class="anchor-point" id="scheduling"></a><a class="anchor" href="#scheduling"><h2>Scheduling</h2><br/></a><p>The RTOS scheduling procedure is where we achieve most of the desired functionality. The following is the source code for thee RTOS inner loop:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span><span class="line-number">21</span><span class="line-number">22</span><span class="line-number">23</span><span class="line-number">24</span><span class="line-number">25</span><span class="line-number">26</span><span class="line-number">27</span><span class="line-number">28</span><span class="line-number">29</span><span class="line-number">30</span><span class="line-number">31</span><span class="line-number">32</span><span class="line-number">33</span><span class="line-number">34</span><span class="line-number">35</span><span class="line-number">36</span><span class="line-number">37</span><span class="line-number">38</span><span class="line-number">39</span><span class="line-number">40</span><span class="line-number">41</span><span class="line-number">42</span><span class="line-number">43</span><span class="line-number">44</span><span class="line-number">45</span><span class="line-number">46</span><span class="line-number">47</span><span class="line-number">48</span><span class="line-number">49</span><span class="line-number">50</span><span class="line-number">51</span><span class="line-number">52</span><span class="line-number">53</span><span class="line-number">54</span><span class="line-number">55</span></div><div class="text"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">()</span> </span>{

    Time::init();

    MAIN_LOOP: <span class="hljs-keyword">for</span> (;;) {

        i64 this_time = Time::now();
        i64 idle_time = <span class="hljs-number">0xFFFF</span>;

        Task_t * task;

        task = Registers::periodic_tasks;
        <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">nullptr</span>) {
            i64 time_remaining = Task::time_remaining(task, this_time);
            <span class="hljs-keyword">if</span> (time_remaining &lt;= <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// We need to pop the task off the list before running the task</span>
                <span class="hljs-comment">// Run will handle re-inserting it correctly</span>
                Registers::periodic_tasks = Task::cdr(task);
                Task::run(task);
                <span class="hljs-keyword">goto</span> MAIN_LOOP;
            } <span class="hljs-keyword">else</span> {
                idle_time = min(idle_time, time_remaining);
            }
        }

        task = Registers::delayed_tasks;
        <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">nullptr</span>) {
            i64 time_remaining = Task::time_remaining(task, this_time);
            <span class="hljs-keyword">if</span> (time_remaining &lt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (Task::fits(task, idle_time)) {
                    <span class="hljs-comment">// We need to pop the task off the list before running </span>
                    <span class="hljs-comment">// the task. Run will handle re-inserting it correctly</span>
                    Registers::delayed_tasks = Task::cdr(task);
                    Task::run(task);
                }   
                <span class="hljs-keyword">goto</span> MAIN_LOOP;
            } <span class="hljs-keyword">else</span> {
                idle_time = min(idle_time, time_remaining);
            }
        }
        task = Registers::event_tasks;
        <span class="hljs-keyword">if</span> (Registers::events) {
            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">nullptr</span>) {
                <span class="hljs-keyword">if</span> (task-&gt;events &amp; Registers::events) {
                    <span class="hljs-keyword">if</span> (Task::fits(task, idle_time)) {
                        Task::run(task);
                    }
                    <span class="hljs-keyword">goto</span> MAIN_LOOP;
                }
                task = Task::cdr(task);
            }
        }
        Time::idle(this_time, idle_time);
    }
}</pre></div></div></div><p>The scheduling procedure is broken into four key steps. Scheduling periodic tasks, scheduling delayed tasks, scheduling event tasks, and idling. By maintaining our periodic and delayed tasks in sorted order, where the first task in the list is the next to run, we only have to check if the first task in each of these lists is ready to run. Task have a Task::time_remaining function which roughly return:</p><div class="math">time remaining = (last time run + delay + period) - now </div><p>This means that a task is ready to run when its time remaining is equal to zero. We compare using less than or equal to for the case of a missed task. In reality this function is slightly more complex as periodic time begins at zero, and the notion of time remaining is not sensible for event-driven tasks.</p><p>If any task is successfully scheduled, or a task fails to fit within the remaining idle time, we immediately return to the start of the loop to ensure that our priority order is properly maintained. A task can fit if its maximum time is less than the current idle time. When first running a task our RTOS is naively optimistic, assuming the task will take zero milliseconds, but each run the maximum time is updated, and if that task does not fit in the idle time it will be skipped.</p><p>When periodic or delayed tasks are run, they are removed from their respective lists, moving the next to run task to the top. They will be reinserted in sorted order by Task::run if necessary.  The same goes for adding event tasks that dynamically change to and from other task types. Note that because event tasks are prioritized first come first serve, we have to iterate over the entire event list in order to check if one needs to be scheduled. </p><p>If no task can currently run we idle until the next time sensitive task is ready to run. This is done using the following function:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span></div><div class="text"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle_mode</span><span class="hljs-params">()</span> </span>{
    set_sleep_mode(SLEEP_MODE_IDLE);
    sleep_mode();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle</span><span class="hljs-params">(i64 this_time, i64 idle_time)</span> </span>{
    <span class="hljs-comment">// Get most accurate idle time</span>
    i64 now_time = now();
    idle_time -= (now_time - this_time);

    <span class="hljs-comment">// Check if time has already passed by now</span>
    <span class="hljs-keyword">if</span> (idle_time &lt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Delay</span>
    <span class="hljs-keyword">while</span>(now() - now_time &lt; idle_time &amp;&amp; !Registers::events) {
        idle_mode();
    }
}</pre></div></div></div><p>During idle time we put the CPU into Idle Mode using the appropriate AVR Libc functions. This helps reduce power consumption. Because we keep time using an interrupt, we are guaranteed to idle for no more than one millisecond at a time. When we wake up we check whether the appropriate amount of time has passed or if an event has gone off, in which case we return to the scheduler.</p><p>If a task misses its scheduled time, an error is traced, however the task will maintain the schedule it would have had should it not have been missed. For instance if a task is expected to run every 1000 ms, runs for the first time at 2000 ms, but misses its second run, running instead at 3001 ms, it will still be scheduled for 4000 ms, not 4001 ms. This makes the RTOS scheduling much easier to predict even when some tasks experience slight jitter.</p><a class="anchor-point" id="tracing"></a><a class="anchor" href="#tracing"><h2>Tracing</h2><br/></a><p>Tracing occurs throughout the RTOS. Anytime a Task is created, started, or stopped, memory is allocated, the CPU is put into idle mode, all of these actions and more are traced. Tracing is done by updating a trace struct with appropriate values and then issuing a call to trace. This will call the UDF of the same name. It is up to the user programmer to decide what to do with tracing information. Additionally, we allow the user programmer to opt out of tracing using preprocessor directives allowing the RTOS to run without the overhead of tracing. The actions captured by tracing are best summarized by looking at the tagged union used to represent the data:</p><div class="editor"><div class="code" data-lang="c++"><div class="gutter"><span class="line-number">1</span><span class="line-number">2</span><span class="line-number">3</span><span class="line-number">4</span><span class="line-number">5</span><span class="line-number">6</span><span class="line-number">7</span><span class="line-number">8</span><span class="line-number">9</span><span class="line-number">10</span><span class="line-number">11</span><span class="line-number">12</span><span class="line-number">13</span><span class="line-number">14</span><span class="line-number">15</span><span class="line-number">16</span><span class="line-number">17</span><span class="line-number">18</span><span class="line-number">19</span><span class="line-number">20</span><span class="line-number">21</span><span class="line-number">22</span><span class="line-number">23</span><span class="line-number">24</span><span class="line-number">25</span><span class="line-number">26</span><span class="line-number">27</span><span class="line-number">28</span><span class="line-number">29</span><span class="line-number">30</span><span class="line-number">31</span><span class="line-number">32</span><span class="line-number">33</span><span class="line-number">34</span><span class="line-number">35</span><span class="line-number">36</span><span class="line-number">37</span><span class="line-number">38</span><span class="line-number">39</span><span class="line-number">40</span><span class="line-number">41</span><span class="line-number">42</span><span class="line-number">43</span><span class="line-number">44</span><span class="line-number">45</span><span class="line-number">46</span><span class="line-number">47</span><span class="line-number">48</span><span class="line-number">49</span><span class="line-number">50</span><span class="line-number">51</span><span class="line-number">52</span><span class="line-number">53</span><span class="line-number">54</span><span class="line-number">55</span><span class="line-number">56</span><span class="line-number">57</span><span class="line-number">58</span><span class="line-number">59</span></div><div class="text"><pre><span class="hljs-keyword">enum</span> Trace_Tag_t {
    <span class="hljs-comment">// Definitions</span>
    Def_Task,  <span class="hljs-comment">// The creation of a task</span>
    Def_Event, <span class="hljs-comment">// The definition of an event</span>
    Def_Alloc, <span class="hljs-comment">// The allocation of memory</span>
    <span class="hljs-comment">// Marks</span>
    Mark_Init,  <span class="hljs-comment">// The start of the RTOS</span>
    Mark_Halt,  <span class="hljs-comment">// RTOS exucution is about to stop</span>
    Mark_Start, <span class="hljs-comment">// The start of a task</span>
    Mark_Stop,  <span class="hljs-comment">// The end of a task</span>
    Mark_Event, <span class="hljs-comment">// The occurence of an event</span>
    Mark_Idle,  <span class="hljs-comment">// Scheduled idle time</span>
    Mark_Wake,  <span class="hljs-comment">// Woke up from idle time</span>
    <span class="hljs-comment">// Errors</span>
    Error_Max_Event,       <span class="hljs-comment">// Maximum number of events exceeded</span>
    Error_Undefined_Event, <span class="hljs-comment">// Undefined event dispatched</span>
    Error_Max_Alloc,       <span class="hljs-comment">// Maximum memory allocation exceeded</span>
    Error_Max_Pool,        <span class="hljs-comment">// Maximum pool allocation exceeded</span>
    Error_Null_Pool,       <span class="hljs-comment">// Null pool or chunk pointer passed as argument</span>
    Error_Max_Task,        <span class="hljs-comment">// Maximum tasks exceeded</span>
    Error_Null_Task,       <span class="hljs-comment">// Null task passed as argument</span>
    Error_Invalid_Task,    <span class="hljs-comment">// Invalid task configuration provided</span>
    Error_Duplicate_Event, <span class="hljs-comment">// Two tasks act on the same event</span>
    Error_Missed,          <span class="hljs-comment">// A task schedule was missed</span>
    <span class="hljs-comment">// Debug</span>
    Debug_Message, <span class="hljs-comment">// Used to send messages to the tracer</span>
};

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trace_t</span> <span class="hljs-title">Trace_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trace_t</span> {</span>
    Trace_Tag_t tag; <span class="hljs-comment">// The trace tag</span>
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">union</span> {
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * handle; };
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * handle; u8 instance; } task;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * handle; Event_t event; } event;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * handle; u16 bytes; } alloc;
        } def;
        <span class="hljs-keyword">union</span> {
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; };
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; u16 heap; } init;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; } halt;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; u8 instance; } start;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; u8 instance; } stop;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; Event_t event; } event;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; } idle;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u64 time; } wake;
        } mark;
        <span class="hljs-keyword">union</span> {
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> Event_t event; } undefined_event;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> Event_t event; } duplicate_event;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u8 instance; } invalid_task;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> u8 instance; } missed;
        } error;
        <span class="hljs-keyword">union</span> {
            <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * message; };
        } debug;
    };
};</pre></div></div></div><p>The Trace tags vary in purpose from scheduling information to runtime error checking. Definition traces, for when a user programmer defines a Task, Event, or allocates memory also provides a human readable handle which can be useful for visualizing trace results. We use a tagged union to try and minimize the overall memory footprint of Traces. The precise size of a Trace will vary between 12 and 18 bytes depending on the specified number of Events the user needs.</p><p>Error traces are provided to the user programmer even when normal tracing is disabled. These correspond to various unexpected events, such as running out of memory, or a task missing its scheduled time. It is up to the user program to decide how to react to these errors. The UDF error function is passed these traces, if it returns true the RTOS will continue execution, otherwise it will halt immediately. This allows programs to react in different ways to different error states. For instance some programs may wish to crash if a specific task is missed, but not crash for others. This system allows for that level of fine grained control.</p><p>The RTOS provides two built in methods of handling traces, pin tracing and serial tracing. With pin tracing the function Trace::configure_pin can be used to assign digital pins to specific tasks. If the UDF provides all traces to Trace::pin_trace, the RTOS will automatically set the appropriate digital pins high and low as tasks run. This makes integration with a logic analyzer trivial. </p><p>Serial tracing will output the trace bytes directly to a serial port. We wrote a small python module that could decode the trace and keep a log. This module would print the trace in a JSON format to stdout as well as print RTOS debug messages to stderr. We combined this functionality with a small web server that served these logs and a small webpage for visualizing the results. To provide an idea of how this works, here is the logic analyzer results for one of our tests, compared to the visualized results from our python module:</p><p><img alt="logic 1" src="/static/blog/rtos2/logic-1.png"/></p><p><img alt="webpage visualization" src="/static/blog/rtos2/webpage-trace.png"/></p><p>In addition to plotting the trace of tasks we also used the webpage to display additional information, such as RTOS memory usage, and general statistics about CPU utilization and task times. This interface provides a sort of real time dashboard for the board, as the webpage can be updated as the board runs and traces arrive on the serial port. This became an indispensable tool during development.</p><a class="anchor-point" id="testing"></a><a class="anchor" href="#testing"><h1>Testing</h1><br/></a><a class="anchor-point" id="overview"></a><a class="anchor" href="#overview"><h2>Overview</h2><br/></a><p>Time-sensitive applications are notoriously hard to test, let alone the RTOS running underneath them. However, to ensure that everything is working properly, testing is necessary. One popular way to test real-time systems is by having the system produce a trace of what is going on so that the user can visually analyze the results. To make sure the system behaves correctly and will not produce unintended results, developers try to force the system to exhibit bad behaviour. If the system has been implemented correctly, it will deal with these situations as predicted and produce an expected trace.</p><p>Time-insensitive features or components of a software program can be tested without producing a trace and instead by writing unit tests. The unit tests described below used software assertions to verify expected behaviour of each component.</p><p>For any time-sensitive features, schedule tests were created to use traces produced by our RTOS to verify correct behaviour.  These tests can be set up to use any of the tracing methods described above as a verification method, as well as additional software assertions. The twenty-one schedule test cases below were ran multiple times during development to ensure systems were not broken in the process and that everything worked as expected after code was finalized.</p><a class="anchor-point" id="unittests"></a><a class="anchor" href="#unittests"><h2>Unit Tests</h2><br/></a><h3 id="eventtasks">Event Tasks</h3><p>Tests a number of functions involving events. Creates and asserts the uniqueness of events, tests dispatching them and ensuring and global variables for the RTOS are updated correctly. Tests that all of these actions produce correct traces. Also tests that error traces will occur if too many events are created, or an undefined event is dispatched.</p><h3 id="memorytests">Memory Tests</h3><p>Tests the static and pool allocators provided by the RTOS.  The static allocator simply provides one time dynamic memory allocation without any ability to free memory. Pool allocators are tested to see if they provide usable, safe memory, and can be combined into lists and deallocated. All of these steps are checked for correct traces, and in the case of either the static allocator or pool allocator running out of memory, an error trace is expected.</p><h3 id="tasktests">Task Tests</h3><p>Tests the creation of tasks, and ensues that RTOS global variables are updated correctly when tasks are dispatched. For instance periodic tasks are dispatched and their order is checked to ensure that the RTOS correctly sorts them. Event tasks are also tested to ensure that they appear in FIFO order and will create an error trace when two tasks attempt to listen to the same event.</p><a class="anchor-point" id="schedulingtests"></a><a class="anchor" href="#schedulingtests"><h2>Scheduling Tests</h2><br/></a><h3 id="01-singleperiodictask">01 - Single Periodic Task</h3><p>Tests that a periodic task runs repeatedly and on time.</p><h3 id="02-multipleperiodictasks">02 - Multiple Periodic Tasks</h3><p>Tests that two alternating periodic tasks run in the correct order and at the correct times.</p><h3 id="03-singleperiodictaskwithoffset">03 - Single Periodic Task with Offset</h3><p>Tests that a periodic task with an initial delay runs at the correct times. For example, a task with a period of 500 milliseconds and an initial delay of 200 milliseconds should run at the following times: 200 ms, 700 ms, 1200 ms, 1700 ms, etc.</p><h3 id="04-overlappingperiodictasks">04 - Overlapping Periodic Tasks</h3><p>Tests that two periodic tasks scheduled to overlap each other will cause the second task to miss its deadline and an Error_Missed error to be sent to the user.</p><h3 id="05-definingtasksinthewrongorder">05 - Defining Tasks in the Wrong Order</h3><p>Tests that the scheduler schedules tasks in the correct order regardless of the order they were dispatched in. Two periodic tasks were created, each with a period of 500 milliseconds. One of the tasks, Task 2, also had an initial delay of 250 milliseconds. Though Task 2 was dispatched to the operating system before Task 1, the scheduler correctly ran Task 1 before Task 2.</p><h3 id="06-instancesofasingletask">06 - Instances of a Single Task</h3><p>Tests that two instances of a single task retain their separate states correctly. Two periodic tasks were created; Task 1&#x27;s state field was assigned the value of true and Task 2&#x27;s was assigned the value of false. Every time the task function was ran, depending on the instance of the task currently being executed, it asserted that the state field was true or false as expected. This demonstrated that two tasks sharing the same task function have separate states.</p><h3 id="07-eventoccurringpriortoosdispatch">07 - Event Occurring Prior to OS Dispatch</h3><p>Tests that the operating system is able to remember events that may occur between the time that the operating system is initialized and dispatched.</p><h3 id="08-terminatingdelayedtask">08 - Terminating Delayed Task</h3><p>Tests that a single delayed task is run once at the correct time and then never run again.</p><h3 id="09-terminatingimmediatetask">09 - Terminating Immediate Task</h3><p>Tests that a single immediate task (a delayed task with delay_ms of zero) is ran once and then never run again.</p><h3 id="10-repeatingdelayedtask">10 - Repeating Delayed Task</h3><p>Tests that a single delayed task that creates itself is put back in the queue and ran again at the correct time.</p><h3 id="11-interruptduringperiodictask">11 - Interrupt During Periodic Task</h3><p>Tests that a periodic task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the periodic task completes. Furthermore, the periodic task is run at its next scheduled period.</p><h3 id="12-interruptduringdelayedtask">12 - Interrupt During Delayed Task</h3><p>Tests that a delayed task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the delayed task completes.</p><h3 id="13-alongtaskinashortidletime">13 - A Long Task in a Short Idle Time</h3><p>Tests the scheduler&#x27;s ability to determine if a task will fit in a given idle time. In this test, a periodic task was created and schedule to run for 40 milliseconds every 500 milliseconds. An event-driven task was created and set to run for 500 milliseconds when triggered. Below, Figure 2 shows the correct sequence of events that occurred. At timing marker A1 the periodic task executed for 40 milliseconds. During that time, a timer interrupt went off, triggering the event. The periodic task completed its execution and then event-driven task ran for 500 milliseconds. When the event-driven task completed, the time was roughly 540. Though the periodic task was supposed to run at time 500, it missed its deadline due to the length of the event-driven task. The operating system will have noted the running time of the event-driven task and at the start of the next idle time, even though the event is triggered again, the scheduler correctly determines that it does not have time to run the event-driven task.</p><p><img alt="logic 2" src="/static/blog/rtos2/logic-2.png"/></p><h3 id="14-multipleinterruptsinalongidletime">14 - Multiple Interrupts in a Long Idle Time</h3><p>Tests that an event-driven task runs multiple times during a single idle period if the event is triggered multiple times and the task fits within the time constraint.</p><h3 id="15-periodictaskbecomingdelayed">15 - Periodic Task Becoming Delayed</h3><p>Tests that a periodic task can dynamically become a delayed task. A periodic task may set its period_ms field to zero and its delay_ms field to non-zero to transform from a periodic task to a delayed task.</p><h3 id="16-delayedtaskbecomingperiodic">16 - Delayed Task Becoming Periodic</h3><p>Tests that a delayed task can dynamically become a periodic task. A delayed task may set its period_ms field to non-zero to transform from a delayed task to ta periodic task. </p><h3 id="17-periodictaskbecomingevent-driven">17 - Periodic Task Becoming Event-Driven</h3><p>Tests that a periodic task can dynamically become an event-driven task. A periodic task may set its period_ms field to zero and its events field to the desired event(s) to transform from a periodic task to an event-driven task.</p><h3 id="18-event-driventaskbecomingdelayed">18 - Event-Driven Task Becoming Delayed</h3><p>Tests that an event-driven task can dynamically become a delayed task. An event-driven task may set its events field to zero and its delay_ms field to non-zero to transform from an event-driven task to a delayed task.</p><h3 id="19-delayedtaskbecomingevent-driven">19 - Delayed Task Becoming Event-Driven</h3><p>Tests that a delayed task can dynamically become an event-driven task. A delayed task may set its events field to the desired event(s) to transform from a delayed task to an event-driven task.</p><h3 id="20-event-driventaskbecomingperiodic">20 - Event-Driven Task Becoming Periodic</h3><p>Tests that an event-driven task can dynamically become a periodic task. An event-driven task may set its events field to zero and its period_ms field to non-zero to transform from an event-driven task to a periodic task.</p><h3 id="21-unchangedstatewhenchangingtasktype">21 - Unchanged State When Changing Task Type</h3><p>Tests that a task&#x27;s state field is retained when changing between task types. If a task dynamically changes its type, its state field should remain unaffected.</p><a class="anchor-point" id="obstacles"></a><a class="anchor" href="#obstacles"><h1>Obstacles</h1><br/></a><p>No software program is written bug-free on the first go around and ours was certainly not an exception. Thanks to our tracing systems and our test suites, we were able to find and resolve multiple bugs in our system. These ranged from simple mistake such as breaking out of a nested loop with continue rather than a goto statement to more serious bugs, such as creating infinite loops. Our implementation of the linked lists which held Task structures could, in some cases, produce cyclical lists that resulted in infinite loops and task not being terminated correctly. Along the same lines, one major bug we found was that a task that dynamically changed to an event-driven task type would never get put into the event-driven task list. This was a result of a missing condition in an if statement in our scheduler. Thankfully, we tested this case and found this bug. </p><p>Another interesting flaw we caught was relating to how we calculated the time remaining until a given task wanted to run next. Our initial calculation did not allow periodic tasks to run at time zero and, instead, calculated their first time remaining to be the length of their period plus their delay. To fix this, we added the first field to the Task_t structure to mark the first running of each task and set our scheduler to perform a slightly different calculation of time remaining on their first run.</p><p>Along with multiple implementation-specific bugs, there were a couple typical pitfalls that we came across while implementing our real time operating system. Thankfully, they were realized before major bugs were caused. These pitfalls included forgetting to declare certain variables as volatile, and forgetting to disable interrupts during certain critical sections. Both of these are common errors made in development of time-sensitive systems.</p></div></div></div><footer><div class="container grid-md"><div class="columns"><div class="column col-3 hide-sm"><a target="_blank" href="https://www.linkedin.com/in/ejrbuss/" class="p-md subtle"><i class="fab fa-linkedin-in fa-lg"></i></a><a target="_blank" href="https://github.com/ejrbuss" class="p-md subtle"><i class="fab fa-github fa-lg"></i></a><a target="_blank" href="https://twitter.com/ejrbuss" class="p-md subtle"><i class="fab fa-twitter fa-lg"></i></a></div><div class="column col-6 col-sm-12"><p class="text-center subtext">Built with <i class="fas fa-heart clr-accent"></i> using <a target="_blank" href="https://nextjs.org/" class="subtle">Nextjs</a>, <a target="_blank" href="https://picturepan2.github.io/spectre/index.html" class="subtle">Spectre.css</a>, &amp; <a href="/blog/site-history" class="subtle">More</a></p></div><div class="column col-3 hide-sm"><p class="text-right subtext">© ejrbuss 2019</p></div></div></div></footer></div><script>__NEXT_DATA__ = {"props":{"pageProps":{}},"page":"/blog/creating-an-rtos-pt-2","query":{},"buildId":"P8USzISEf7rdf~FIp5KnP","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/blog/creating-an-rtos-pt-2" src="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/blog/creating-an-rtos-pt-2.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/static/P8USzISEf7rdf~FIp5KnP/pages/_error.js"></script><script src="/_next/static/runtime/webpack-f4542de9ce6104e90191.js" async=""></script><script src="/_next/static/chunks/commons.2ccf073e64d3d8a62c5c.js" async=""></script><script src="/_next/static/runtime/main-98aa4765ad2a12a28472.js" async=""></script></body></html>